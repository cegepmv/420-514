+++
draft = false
title = 'Introduction Ã  TypeScript'
weight = 41
+++

## ğŸ”¹Quâ€™est-ce que TypeScript ?

TypeScript est un langage de programmation open-source, câ€™est un sur-ensemble de JavaScript qui ajoute la vÃ©rification statique des types, ce qui signifie que les types de donnÃ©es sont dÃ©finis explicitement lors de l'Ã©criture du code.

TypeScript met l'accent sur le typage fort et vous permet d'Ã©crire du code plus sÃ»r : lisible, moins sujet aux erreurs et plus facile Ã  maintenir.

## ğŸ”¹Pourquoi utiliser TypeScript plutÃ´t que JavaScript ?

Utiliser TypeScript plutÃ´t que JavaScript prÃ©sente plusieurs avantages, notamment pour les projets complexes ou de grande envergure. Voici quelques uns :

### 1. **Typage statique** :

- **JavaScript** : Le typage est dynamique, ce qui signifie que les types de variables peuvent changer au fil de l'exÃ©cution. Cela peut entraÃ®ner des erreurs difficiles Ã  dÃ©tecter, notamment dans de gros projets oÃ¹ des erreurs de type peuvent se propager.
- **TypeScript** : Le typage statique signifie que les types sont vÃ©rifiÃ©s Ã  la compilation. Si une variable est dÃ©finie comme un nombre (`number`), elle ne pourra pas Ãªtre utilisÃ©e comme une chaÃ®ne de caractÃ¨res (`string`). Cela permet de dÃ©tecter de nombreuses erreurs avant mÃªme l'exÃ©cution.

### Exemple :

```jsx
// JavaScript
let x = 10;
x = 'hello';  // Pas d'erreur dans JavaScript, mÃªme si c'est incohÃ©rent.
```

```tsx
// TypeScript
let x: number = 10;
x = 'hello';  // Erreur Ã  la compilation : Type 'string' is not assignable to type 'number'.
```

### 2. **DÃ©tection d'erreurs plus rapide** :

- **JavaScript** : Les erreurs liÃ©es aux types et aux incohÃ©rences logiques ne sont souvent dÃ©tectÃ©es qu'au moment de l'exÃ©cution, ce qui peut rendre le dÃ©bogage plus difficile.
- **TypeScript** : GrÃ¢ce Ã  la compilation et Ã  la vÃ©rification des types avant l'exÃ©cution, TypeScript aide Ã  attraper ces erreurs en amont. Cela permet de rÃ©duire les bugs en production.

### Exemple :

```tsx
function multiply(a: number, b: number): number {
  return a * b;
}

multiply(5, '10');  // Erreur Ã  la compilation car '10' est une chaÃ®ne et non un nombre.
```

### 3. **Meilleure lisibilitÃ© et maintenabilitÃ©** :

- **JavaScript** : Sans typage statique, il peut Ãªtre difficile de comprendre rapidement quelles sont les structures de donnÃ©es attendues, surtout dans un grand projet oÃ¹ de nombreuses fonctions et objets sont en interaction.
- **TypeScript** : Avec les annotations de types, il est plus facile de comprendre ce que fait une fonction ou quelles propriÃ©tÃ©s un objet doit avoir. Cela rend le code plus explicite et aide les Ã©quipes Ã  maintenir de grands projets Ã  long terme.

### Exemple :

```tsx
interface User {
  name: string;
  age: number;
  email?: string;  // propriÃ©tÃ© optionnelle
}

function greetUser(user: User): string {
  return `Hello, ${user.name}!`;
}
```

Dans cet exemple, l'interface `User` dÃ©finit clairement la structure de l'objet, rendant le code plus facile Ã  comprendre et Ã  maintenir.

### 4. **Support des outils de dÃ©veloppement** :

- **JavaScript** : Bien qu'il existe de nombreux bons outils pour JavaScript, la nature dynamique du langage limite certaines fonctionnalitÃ©s avancÃ©es, comme l'auto-complÃ©tion prÃ©cise ou la navigation facile dans le code.
- **TypeScript** : Les Ã©diteurs comme Visual Studio Code bÃ©nÃ©ficient Ã©normÃ©ment des informations de type fournies par TypeScript. Cela amÃ©liore l'auto-complÃ©tion, les suggestions de code, la documentation en ligne et la navigation Ã  travers les fichiers.

### Exemple :

Lorsque tu passes la souris sur une variable ou une fonction dans un Ã©diteur comme VS Code avec TypeScript, tu obtiens des informations sur les types, les arguments attendus et les types de retour, ce qui facilite l'Ã©criture de code.

### 5. **Support de fonctionnalitÃ©s modernes de JavaScript** :

- **JavaScript** : Les nouvelles fonctionnalitÃ©s de JavaScript (ES6, ESNext) peuvent Ãªtre utilisÃ©es, mais cela dÃ©pend du support des environnements d'exÃ©cution ou de la compatibilitÃ© avec les anciens navigateurs.
- **TypeScript** : TypeScript compile le code vers une version spÃ©cifique de JavaScript (comme ES5 ou ES6). Cela permet d'utiliser les fonctionnalitÃ©s les plus rÃ©centes de JavaScript tout en garantissant la compatibilitÃ© avec les anciens environnements.

### Exemple :

TypeScript te permet d'utiliser des fonctionnalitÃ©s comme les **async/await**, les **classes**, les **modules**, mÃªme si on doit prendre en charge des environnements qui n'ont pas encore adoptÃ© ces fonctionnalitÃ©s.

### 6. **Programmation orientÃ©e objet** :

- **JavaScript** : JavaScript est un langage orientÃ© prototype, et bien qu'il prenne en charge la POO avec les classes ES6, son support n'est pas aussi strict.
- **TypeScript** : TypeScript introduit une POO plus formelle avec des classes, des interfaces, des modificateurs d'accÃ¨s (`public`, `private`, `protected`), et des constructeurs qui facilitent l'encapsulation et la rÃ©utilisation de code de maniÃ¨re plus structurÃ©e.

### Exemple :

```tsx
class Person {
  private name: string;

  constructor(name: string) {
    this.name = name;
  }

  public getName(): string {
    return this.name;
  }
}

const john = new Person('John');
console.log(john.getName());  // John
```

### 7. **InteropÃ©rabilitÃ© avec JavaScript** :

- **JavaScript** : C'est la base de TypeScript, donc tout code JavaScript valide est Ã©galement valide en TypeScript.
- **TypeScript** : TypeScript permet d'utiliser du code JavaScript existant, ce qui facilite la transition progressive. Tu peux convertir un projet JavaScript en TypeScript de maniÃ¨re incrÃ©mentale, sans tout rÃ©Ã©crire d'un coup.

### Exemple :

```tsx
// Fichier JavaScript que tu peux migrer progressivement
const greet = (name) => {
  console.log(`Hello, ${name}`);
};

greet('Alice');  // Fonctionne en TypeScript aussi
```

### 8. **Ã‰cosystÃ¨me de types** :

- **JavaScript** : Les bibliothÃ¨ques et frameworks sont Ã©crits en JavaScript, mais il peut Ãªtre difficile de savoir exactement quels types de donnÃ©es sont attendus par ces bibliothÃ¨ques.
- **TypeScript** : GrÃ¢ce aux dÃ©finitions de types fournies par les fichiers `@types`, on peut avoir une meilleure connaissance des types utilisÃ©s par des bibliothÃ¨ques comme Express, React, ou mÃªme des API tiers, ce qui nous permet dâ€™intÃ©grer ces bibliothÃ¨ques tout en conservant la sÃ©curitÃ© des types.

### Exemple :

```tsx
import express, { Request, Response } from 'express';

const app = express();

app.get('/', (req: Request, res: Response) => {
  res.send('Hello World with TypeScript!');
});
```

Ici, TypeScript te donne un support de typage pour les objets `Request` et `Response` d'Express, rendant ton code plus robuste.

### 9. **Grande communautÃ© et adoption croissante** :

- **JavaScript** : Il reste largement utilisÃ© et est essentiel pour le dÃ©veloppement web.
- **TypeScript** : GrÃ¢ce Ã  sa compatibilitÃ© avec JavaScript et ses nombreux avantages, TypeScript a Ã©tÃ© massivement adoptÃ© par de grandes entreprises comme Microsoft, Google, et mÃªme des projets open-source comme Angular et Vue.js. Cela crÃ©e un Ã©cosystÃ¨me riche avec une communautÃ© active.

On peut dire que **TypeScript** offre une expÃ©rience de dÃ©veloppement plus sÃ©curisÃ©e, plus robuste et plus maintenable, surtout pour les projets complexes ou Ã  long terme. Il aide Ã  rÃ©duire les bugs, Ã  amÃ©liorer la productivitÃ© grÃ¢ce Ã  des outils de dÃ©veloppement avancÃ©s et Ã  rendre le code plus lisible et plus structurÃ©. Cependant, il demande une phase de compilation supplÃ©mentaire, et la courbe dâ€™apprentissage peut Ãªtre plus raide pour ceux qui viennent du pur JavaScript.

## ğŸ”¹Installation et configuration d'un environnement de dÃ©veloppement TypeScript

### **IntÃ©gration TypeScript dans un projet Node.js/Express**

L'intÃ©gration de TypeScript dans un projet Node.js/Express est assez simple. Voici les Ã©tapes :

1. **Initialiser le projet** :
Si tu nâ€™as pas encore de projet Node.js/Express, initialise-le avec `npm` :
    
    ```bash
    npm init -y
    ```
    
2. **Installer TypeScript et les types pour Node et Express** :
    
    ```bash
    npm install express
    npm install typescript @types/node @types/express ts-node-dev --save-dev
    
    ```
    
3. **CrÃ©er un fichier de configuration `tsconfig.json`** :
    
    ```bash
    npx tsc --init
    ```
    
    Cela gÃ©nÃ¨re un fichier de configuration TypeScript qui peut Ãªtre ajustÃ© en fonction des besoins. Voici un exemple basique :
    
    ```json
    {
      "compilerOptions": {
        "target": "ES6",
        "module": "commonjs",
        "outDir": "./dist",
        "rootDir": "./src",
        "esModuleInterop": true,
        "strict": true
      },
      "include": ["src/**/*.ts"],
      "exclude": ["node_modules"]
    }
    ```
    
4. **CrÃ©er une structure de rÃ©pertoire TypeScript** :
Dans le dossier `src`, tu peux crÃ©er tes fichiers `.ts`. Par exemple, un fichier `src/index.ts` pour ton serveur Express :
    
    ```tsx
    import express, { Request, Response } from 'express';
    
    const app = express();
    const port = 3000;
    
    app.get('/', (req: Request, res: Response) => {
      res.send('Hello TypeScript with Express!');
    });
    
    app.listen(port, () => {
      console.log(`Server is running on port ${port}`);
    });
    ```
    
5. **Lancer le projet avec TypeScript** :
Tu peux utiliser `ts-node-dev` pour lancer ton serveur avec TypeScript :
    
    ```bash
    npx ts-node-dev src/index.ts
    ```
    

## ğŸ”¹Les types de base et dÃ©clarations de variables

### 1. **DÃ©claration de variables**

En TypeScript, tu peux dÃ©clarer des variables de plusieurs faÃ§ons similaires Ã  JavaScript, mais avec la possibilitÃ© de spÃ©cifier explicitement les types.

- **`let`** : DÃ©clare une variable dont la valeur peut Ãªtre modifiÃ©e.
- **`const`** : DÃ©clare une variable constante, dont la valeur ne peut pas Ãªtre rÃ©assignÃ©e.
- **`var`** : Ne doit plus Ãªtre utilisÃ© car `let` et `const` sont prÃ©fÃ©rÃ©s pour Ã©viter les comportements inattendus liÃ©s Ã  l'Ã©tendue de la variable.

#### Exemple :

```tsx
let age: number = 30;   // variable modifiable
const name: string = "Alice";   // variable constante
```

### 2. **Les types de base**

Voici les types primitifs de base les plus courants en TypeScript :

#### a. **`number`** : pour les nombres

Tous les nombres en TypeScript (qu'ils soient entiers ou dÃ©cimaux) sont de type `number`.

```tsx
let age: number = 25;
let price: number = 19.99;
```

#### b. **`string`** : pour les chaÃ®nes de caractÃ¨res

Les chaÃ®nes de caractÃ¨res sont dÃ©finies avec des guillemets simples ou doubles.

```tsx
let name: string = "Alice";
let greeting: string = `Hello, ${name}`;  // utilisation des template strings
```

#### c. **`boolean`** : pour les valeurs boolÃ©ennes

Le type `boolean` accepte les valeurs `true` et `false`.

```tsx
let isStudent: boolean = true;
let hasGraduated: boolean = false;
```

#### d. **`array`** : pour les tableaux

Les tableaux peuvent Ãªtre typÃ©s pour contenir un type spÃ©cifique d'Ã©lÃ©ments. Deux syntaxes sont possibles :

1. Utilisation des crochets `[]` :
    
    ```tsx
    let numbers: number[] = [1, 2, 3, 4];
    let names: string[] = ["Alice", "Bob", "Charlie"];
    ```
    
2. Utilisation du type `Array<type>` :
    
    ```tsx
    let numbers: Array<number> = [1, 2, 3, 4];
    let names: Array<string> = ["Alice", "Bob", "Charlie"];
    ```
    

#### e. **`tuple`** : pour les tableaux de longueurs fixes avec des types prÃ©dÃ©finis pour chaque Ã©lÃ©ment

Un `tuple` est un tableau avec un nombre d'Ã©lÃ©ments fixe, oÃ¹ chaque Ã©lÃ©ment peut avoir un type diffÃ©rent.

```tsx
let person: [string, number] = ["Alice", 25];
```

Dans cet exemple, le premier Ã©lÃ©ment du tuple est une chaÃ®ne et le second est un nombre.

#### f. **`enum`** : pour les ensembles de valeurs nommÃ©es

Les Ã©numÃ©rations (`enum`) permettent de dÃ©finir un ensemble de valeurs nommÃ©es. Par dÃ©faut, elles sont numÃ©rotÃ©es Ã  partir de 0, mais tu peux aussi attribuer des valeurs personnalisÃ©es.

```tsx
enum Color {
  Red,     // 0
  Green,   // 1
  Blue     // 2
}

let myColor: Color = Color.Green;
console.log(myColor);  // 1
```

Avec des valeurs personnalisÃ©es :

```tsx
enum Status {
  Active = 1,
  Inactive = 0,
  Pending = -1
}

let userStatus: Status = Status.Active;
console.log(userStatus);  // 1
```

#### g. **`any`** : pour dÃ©sactiver la vÃ©rification des types

Le type `any` dÃ©sactive la vÃ©rification des types et permet de stocker des valeurs de nâ€™importe quel type. Ã€ utiliser avec prÃ©caution, car cela peut annuler les avantages du typage statique.

```tsx
let randomValue: any = 10;
randomValue = "Hello";  // autorisÃ©
randomValue = true;     // autorisÃ©

```

#### h. **`void`** : pour les fonctions sans valeur de retour

Le type `void` est utilisÃ© pour spÃ©cifier qu'une fonction ne retourne rien.

```tsx
function logMessage(message: string): void {
  console.log(message);
}

```

#### i. **`null` et `undefined`** : pour l'absence de valeur

TypeScript a des types spÃ©cifiques pour `null` et `undefined`. Par dÃ©faut, une variable de type `null` ou `undefined` n'est pas assignable Ã  d'autres types Ã  moins que le mode strict soit dÃ©sactivÃ© ou explicitement dÃ©fini.

```tsx
let u: undefined = undefined;
let n: null = null;
```

#### j. **`object`** : pour tout type qui nâ€™est ni un type primitif

Le type `object` est utilisÃ© pour dÃ©signer tout type qui n'est ni `number`, `string`, `boolean`, `symbol`, `null`, ni `undefined`.

```tsx
let person: object = { name: "Alice", age: 25 };
```

### 3. **DÃ©clarations de types personnalisÃ©s**

#### a. **Type unions**

Les unions permettent de combiner plusieurs types. Une variable de type union peut prendre plusieurs types de valeurs.

```tsx
let id: number | string;
id = 123;    // valide
id = "ABC";  // valide
```

#### b. **Alias de type**

Les alias de type permettent de dÃ©finir un nom pour un ensemble de types. Cela rend le code plus lisible, surtout pour les types complexes.

```tsx
type UserId = number | string;
let userId: UserId;
userId = 123;     // valide
userId = "ABC";   // valide
```

### 4. **Type inference (infÃ©rence de type)**

TypeScript est capable de dÃ©duire les types sans que tu aies besoin de les spÃ©cifier explicitement. Par exemple, si tu initialises une variable avec un nombre, TypeScript comprendra qu'elle est de type `number`.

#### Exemple :

```tsx
let age = 30;  // TypeScript infÃ¨re automatiquement que `age` est de type `number`.
age = "30";    // Erreur, car `age` est supposÃ© Ãªtre un nombre.
```

### 5. **Types littÃ©raux**

Un type littÃ©ral permet de restreindre les valeurs qu'une variable peut prendre Ã  des valeurs spÃ©cifiques.

```tsx
let direction: "left" | "right" | "up" | "down";
direction = "left";  // valide
direction = "center";  // Erreur, "center" n'est pas un type valide
```

### 6.  **Annotations** et **l'infÃ©rence de types**

En TypeScript, il existe deux mÃ©thodes principales pour gÃ©rer les types : **les annotations de types** et **l'infÃ©rence de types**.

#### a. **Annotations de types**

Les **annotations de types** permettent de spÃ©cifier explicitement le type d'une variable, d'un paramÃ¨tre de fonction ou de la valeur de retour d'une fonction. Cela aide Ã  renforcer la sÃ©curitÃ© des types et Ã  rendre le code plus lisible.

#### Exemple basique :

```tsx
let age: number = 30;
let name: string = "Alice";
let isStudent: boolean = true;
```

Dans cet exemple :

- `age` est explicitement annotÃ© comme un `number`.
- `name` est un `string`.
- `isStudent` est un `boolean`.

Les annotations peuvent Ã©galement Ãªtre utilisÃ©es dans les fonctions pour spÃ©cifier les types des paramÃ¨tres et des valeurs de retour.

#### Exemple avec fonction :

```tsx
function greet(name: string): string {
  return `Hello, ${name}`;
}

let message: string = greet("Alice");  // "Hello, Alice"
```

Ici :

- Le paramÃ¨tre `name` doit Ãªtre de type `string`.
- La fonction retourne une valeur de type `string`.

#### Avantages des annotations de types :

- Elles rendent le code plus **prÃ©visible** et plus facile Ã  comprendre.
- Elles permettent d'attraper les erreurs liÃ©es aux types **avant l'exÃ©cution**.
- Elles offrent un contrÃ´le total sur les types utilisÃ©s dans le code.

#### b. **InfÃ©rence de types**

L'**infÃ©rence de types** est le mÃ©canisme par lequel TypeScript dÃ©duit automatiquement le type d'une variable ou d'une fonction sans que tu aies besoin de le spÃ©cifier explicitement.

#### Exemple d'infÃ©rence de types :

```tsx
let age = 30;
let name = "Alice";
```

Dans cet exemple, TypeScript infÃ¨re automatiquement que :

- `age` est de type `number` car il a Ã©tÃ© initialisÃ© avec un nombre.
- `name` est de type `string` car il a Ã©tÃ© initialisÃ© avec une chaÃ®ne de caractÃ¨res.

TypeScript est capable de dÃ©duire les types dans la plupart des cas Ã  partir des valeurs initiales assignÃ©es aux variables.

#### InfÃ©rence dans les fonctions :

Si TypeScript peut dÃ©duire le type de retour d'une fonction Ã  partir du code de la fonction, il n'est pas nÃ©cessaire de spÃ©cifier explicitement un type de retour.

```tsx
function add(a: number, b: number) {
  return a + b;
}

let result = add(10, 20);  // TypeScript infÃ¨re que result est de type number
```

Dans cet exemple, TypeScript infÃ¨re que la fonction `add` retourne un `number` (car l'addition de deux nombres retourne un nombre) et dÃ©duit que `result` est Ã©galement de type `number`.

#### Limites de l'infÃ©rence :

Bien que l'infÃ©rence de types soit puissante, elle n'est pas toujours idÃ©ale, notamment dans les cas complexes oÃ¹ il peut Ãªtre difficile pour TypeScript de deviner le type exact attendu. C'est pourquoi l'utilisation d'annotations de types est parfois prÃ©fÃ©rable.

#### c. **Combinaison d'annotations de types et d'infÃ©rence**

On peut combiner les deux approches dans ton code. Par exemple, on peut laisser TypeScript infÃ©rer certains types simples tout en utilisant des annotations explicites pour les types plus complexes.

#### Exemple :

```tsx
let age = 30;  // TypeScript infÃ¨re que age est un number
let name: string = "Alice";  // Type annotÃ© explicitement
```

Dans cet exemple, `age` est laissÃ© Ã  l'infÃ©rence de TypeScript, tandis que `name` est annotÃ© explicitement.

#### d. **Annotations de types dans les objets et tableaux**

TypeScript permet Ã©galement d'annoter les types des objets, des tableaux, et des tuples.

#### Objet annotÃ© explicitement :

```tsx
let person: { name: string; age: number } = {
  name: "Alice",
  age: 25
};
```

#### Tableau annotÃ© explicitement :

```tsx
let numbers: number[] = [1, 2, 3, 4];
```

#### e. **Annotations de types dans les fonctions**

L'annotation des fonctions permet de contrÃ´ler non seulement les types des paramÃ¨tres mais aussi ceux des valeurs de retour.

#### Exemple avec paramÃ¨tres et type de retour :

```tsx
function multiply(a: number, b: number): number {
  return a * b;
}
```

Dans cet exemple :

- `a` et `b` sont des paramÃ¨tres annotÃ©s comme des `number`.
- La fonction retourne un `number`, ce qui est explicitement indiquÃ©.

#### Type implicite pour la valeur de retour :

Si TypeScript peut infÃ©rer le type de retour, il n'est pas nÃ©cessaire de l'annoter.

```tsx
function subtract(a: number, b: number) {
  return a - b;  // TypeScript infÃ¨re que la valeur de retour est un number
}
```

#### f. **InfÃ©rence de type dans les fonctions anonymes et les fonctions flÃ©chÃ©es**

Dans les fonctions anonymes ou flÃ©chÃ©es, TypeScript infÃ¨re automatiquement les types Ã  partir du contexte.

#### Exemple :

```tsx
let greet = (name: string) => {
  return `Hello, ${name}`;
};
```

TypeScript dÃ©duit ici que la fonction flÃ©chÃ©e `greet` prend un paramÃ¨tre de type `string` et retourne Ã©galement une `string`, sans qu'il soit nÃ©cessaire de spÃ©cifier explicitement le type de retour.

#### g. **Avantages de l'infÃ©rence de type**

- **SimplicitÃ©** : L'infÃ©rence de type permet d'Ã©crire du code plus concis, car il n'est pas nÃ©cessaire de toujours dÃ©clarer les types.
- **LisibilitÃ©** : Dans des cas simples ou Ã©vidents, l'infÃ©rence permet de ne pas surcharger le code avec des annotations de types inutiles.

#### h. **Cas oÃ¹ les annotations sont nÃ©cessaires**

Il y a des situations oÃ¹ l'infÃ©rence seule n'est pas suffisante ou peut mener Ã  des comportements inattendus. Voici quelques exemples oÃ¹ les annotations sont indispensables :

### 7. **Les objets complexes**

Pour des objets ou structures de donnÃ©es complexes, il est souvent nÃ©cessaire d'utiliser des annotations explicites pour clarifier les types.

```tsx
let user: { name: string; age: number } = {
  name: "Alice",
  age: 25
};
```

### 8. **Les fonctions avec des retours implicites multiples**

Lorsque tu as plusieurs retours possibles dans une fonction, TypeScript pourrait infÃ©rer des types incohÃ©rents. Utiliser des annotations de type de retour dans ces situations est plus sÃ»r.

```tsx
function getResult(success: boolean): string | number {
  if (success) {
    return "Success";
  } else {
    return 404;
  }
}
```

### 9. **Cas oÃ¹ l'infÃ©rence de type est suffisante**

Dans des situations simples, comme l'affectation directe de valeurs primitives (`number`, `string`, `boolean`), l'infÃ©rence de types est souvent suffisante.

```tsx
let counter = 0;  // TypeScript infÃ¨re que `counter` est de type number
let message = "Hello!";  // TypeScript infÃ¨re que `message` est de type string
```

L'Ã©quilibre entre annotations et infÃ©rence dÃ©pend de la complexitÃ© du code et de la clartÃ© souhaitÃ©e. Les annotations sont essentielles pour des fonctions complexes ou des structures de donnÃ©es avancÃ©es, tandis que l'infÃ©rence fonctionne bien dans des cas plus simples.

## ğŸ”¹Les fonctions et les classes

### 1. **Fonctions**

Les fonctions en TypeScript ressemblent beaucoup Ã  celles en JavaScript, mais avec des fonctionnalitÃ©s supplÃ©mentaires liÃ©es au typage.

#### a. **DÃ©finition de fonctions avec types**

Dans TypeScript, tu peux dÃ©finir les types des paramÃ¨tres et le type de retour d'une fonction.

#### Exemple simple :

```tsx
function add(a: number, b: number): number {
  return a + b;
}
```

- Ici, les paramÃ¨tres `a` et `b` sont des nombres (`number`).
- La fonction retourne Ã©galement un `number`, ce qui est spÃ©cifiÃ© aprÃ¨s `: number`.

#### b. **ParamÃ¨tres optionnels et valeurs par dÃ©faut**

Tu peux rendre certains paramÃ¨tres **optionnels** en utilisant `?` et donner des **valeurs par dÃ©faut** aux paramÃ¨tres.

#### Exemple avec un paramÃ¨tre optionnel :

```tsx
function greet(name: string, greeting?: string): string {
  return `${greeting || 'Hello'}, ${name}!`;
}

console.log(greet("Alice")); // Hello, Alice!
console.log(greet("Bob", "Hi")); // Hi, Bob!
```

- Le paramÃ¨tre `greeting` est optionnel (`?`), donc si aucune valeur n'est fournie, la valeur par dÃ©faut `'Hello'` est utilisÃ©e.

#### Exemple avec valeur par dÃ©faut :

```tsx
function greet(name: string, greeting: string = "Hello"): string {
  return `${greeting}, ${name}!`;
}

console.log(greet("Alice")); // Hello, Alice!
console.log(greet("Bob", "Hi")); // Hi, Bob!
```

- Ici, `greeting` a une valeur par dÃ©faut `"Hello"` qui est utilisÃ©e si aucun autre argument n'est fourni.

#### c. **Fonctions avec types complexes**

Les fonctions peuvent Ã©galement accepter des objets, des tableaux, ou des types complexes en tant que paramÃ¨tres.

#### Exemple avec un objet :

```tsx
interface User {
  name: string;
  age: number;
}

function greetUser(user: User): string {
  return `Hello, ${user.name}, who is ${user.age} years old!`;
}

console.log(greetUser({ name: "Alice", age: 25 })); // Hello, Alice, who is 25 years old!
```

#### d. **Types de retour `void` et `never`**

- Le type `void` est utilisÃ© pour les fonctions qui ne retournent rien.
- Le type `never` est utilisÃ© pour les fonctions qui ne terminent jamais leur exÃ©cution ou qui lÃ¨vent toujours une exception.

#### Exemple de `void` :

```tsx
function logMessage(message: string): void {
  console.log(message);
}
```

#### Exemple de `never` :

```tsx
function throwError(errorMsg: string): never {
  throw new Error(errorMsg);
}
```

#### e. **Fonctions flÃ©chÃ©es (arrow functions)**

Les **fonctions flÃ©chÃ©es** sont courantes en TypeScript, comme en JavaScript. Elles ont une syntaxe concise et capturent le contexte de `this` environnant.

#### Exemple :

```tsx
const multiply = (a: number, b: number): number => {
  return a * b;
};

console.log(multiply(2, 3)); // 6
```


### 2. **Classes**

Les **classes** en TypeScript permettent d'utiliser la programmation orientÃ©e objet (POO). TypeScript amÃ©liore les classes en ajoutant des types, des modificateurs de visibilitÃ© (`public`, `private`, `protected`) et des interfaces.

#### a. **DÃ©finition de classes**

Une classe est dÃ©finie avec le mot-clÃ© `class`. Elle peut avoir des propriÃ©tÃ©s, un constructeur et des mÃ©thodes.

#### Exemple simple :

```tsx
class Person {
  name: string;
  age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }

  greet(): string {
    return `Hello, my name is ${this.name} and I'm ${this.age} years old.`;
  }
}

const alice = new Person("Alice", 25);
console.log(alice.greet()); // Hello, my name is Alice and I'm 25 years old.
```

Dans cet exemple :

- La classe `Person` a deux propriÃ©tÃ©s : `name` et `age`.
- Le constructeur initialise ces propriÃ©tÃ©s.
- La mÃ©thode `greet()` retourne une chaÃ®ne de caractÃ¨res.

#### b. **Modificateurs de visibilitÃ©**

Les classes TypeScript supportent les modificateurs d'accÃ¨s :

- **`public`** : Le membre est accessible partout. C'est le comportement par dÃ©faut.
- **`private`** : Le membre est accessible uniquement Ã  l'intÃ©rieur de la classe.
- **`protected`** : Le membre est accessible Ã  l'intÃ©rieur de la classe et des classes dÃ©rivÃ©es (hÃ©ritÃ©es).

#### Exemple avec modificateurs :

```tsx
class Person {
  private name: string;
  protected age: number;
  public country: string;

  constructor(name: string, age: number, country: string) {
    this.name = name;
    this.age = age;
    this.country = country;
  }

  public greet(): string {
    return `Hello, I am from ${this.country}`;
  }
}

class Employee extends Person {
  private position: string;

  constructor(name: string, age: number, country: string, position: string) {
    super(name, age, country);
    this.position = position;
  }

  public getDetails(): string {
    return `${this.greet()} and I work as a ${this.position}.`;
  }
}

const employee = new Employee("Bob", 30, "Canada", "Developer");
console.log(employee.getDetails()); // Hello, I am from Canada and I work as a Developer.
```

Dans cet exemple :

- `name` est `private` : il ne peut Ãªtre accÃ©dÃ© que dans la classe `Person`.
- `age` est `protected` : il peut Ãªtre accÃ©dÃ© dans `Person` et dans `Employee`.
- `country` est `public` : il peut Ãªtre accÃ©dÃ© partout.

#### c. **HÃ©ritage (extends)**

Une classe peut hÃ©riter d'une autre classe en utilisant `extends`. La classe enfant a accÃ¨s aux propriÃ©tÃ©s et mÃ©thodes de la classe parente.

#### Exemple d'hÃ©ritage :

```tsx
class Animal {
  name: string;

  constructor(name: string) {
    this.name = name;
  }

  speak(): string {
    return `${this.name} makes a sound.`;
  }
}

class Dog extends Animal {
  speak(): string {
    return `${this.name} barks.`;
  }
}

const dog = new Dog("Rex");
console.log(dog.speak()); // Rex barks.
```

#### d. **Interfaces dans les classes**

Une classe peut implÃ©menter une ou plusieurs interfaces pour s'assurer qu'elle respecte certaines signatures.

#### Exemple :

```tsx
interface Shape {
  area(): number;
}

class Rectangle implements Shape {
  width: number;
  height: number;

  constructor(width: number, height: number) {
    this.width = width;
    this.height = height;
  }

  area(): number {
    return this.width * this.height;
  }
}

const rect = new Rectangle(10, 20);
console.log(rect.area()); // 200
```

#### e. **Classes abstraites**

Les **classes abstraites** ne peuvent pas Ãªtre instanciÃ©es directement. Elles sont utilisÃ©es comme base pour d'autres classes. Une mÃ©thode abstraite est une mÃ©thode sans implÃ©mentation dans la classe abstraite.

### Exemple :

```tsx
abstract class Animal {
  abstract makeSound(): void;  // MÃ©thode abstraite

  move(): void {
    console.log("Moving...");
  }
}

class Dog extends Animal {
  makeSound(): void {
    console.log("Bark!");
  }
}

const dog = new Dog();
dog.makeSound(); // Bark!
dog.move(); // Moving...
```

Dans cet exemple, la mÃ©thode `makeSound()` est dÃ©clarÃ©e abstraite dans `Animal`, donc chaque classe enfant doit l'implÃ©menter.

**Exercice :**
CrÃ©ez une classe `Film` avec des propriÃ©tÃ©s telles que le titre, lâ€™annÃ©e de sortie, et un rÃ©sumÃ©. Ensuite, crÃ©ez une mÃ©thode pour afficher les informations du film.
