var relearn_searchindex = [
  {
    "breadcrumb": "Collecte et interprétation de données",
    "content": "Dans ce module nous ferons une courte révision des notions essentielles au cours.",
    "description": "Dans ce module nous ferons une courte révision des notions essentielles au cours.",
    "tags": [],
    "title": "Préalables",
    "uri": "/420-514/intro/index.html"
  },
  {
    "breadcrumb": "Collecte et interprétation de données",
    "content": "Dans ce module, on va développer une API ou une application serveur complète avec un cadriciel moderne.",
    "description": "Dans ce module, on va développer une API ou une application serveur complète avec un cadriciel moderne.",
    "tags": [],
    "title": "Cadriciel (framework) côté serveur : Node.js / express",
    "uri": "/420-514/nodejsframeworkexpress/index.html"
  },
  {
    "breadcrumb": "Collecte et interprétation de données",
    "content": "Dans ce chapitre, nous allons découvrir le fonctionnement des requêtes HTTP et leur rôle dans l’échange de données sur le Web. Nous verrons comment un client, tel qu’un navigateur, envoie une requête au serveur pour accéder à une ressource, et comment le serveur répond avec un code de statut, des en-têtes et éventuellement un contenu. Nous présenterons les différentes méthodes HTTP (GET, POST, etc.), la structure d’une requête et d’une réponse, ainsi que des exemples concrets d’échanges entre client et serveur.",
    "description": "Dans ce chapitre, nous allons découvrir le fonctionnement des requêtes HTTP et leur rôle dans l’échange de données sur le Web. Nous verrons comment un client, tel qu’un navigateur, envoie une requête au serveur pour accéder à une ressource, et comment le serveur répond avec un code de statut, des en-têtes et éventuellement un contenu. Nous présenterons les différentes méthodes HTTP (GET, POST, etc.), la structure d’une requête et d’une réponse, ainsi que des exemples concrets d’échanges entre client et serveur.",
    "tags": [],
    "title": "Requêtes HTTP et format de données",
    "uri": "/420-514/httprequestdataformat/index.html"
  },
  {
    "breadcrumb": "Collecte et interprétation de données \u003e Préalables",
    "content": "Rappel API REST 🌼 Une API REST se doit d’être sans état Stateless. La communication entre le client et le serveur ne doit pas dépendre d’un quelconque contexte provenant du serveur. 🌼 Ainsi, chaque requête doit contenir l’ensemble des informations nécessaires à son traitement. Cela permet au de traiter indifféremment les requêtes de plusieurs clients via de multiples instances de serveurs.\n🌼 Pour chaque réponse renvoyée par l’API, un code doit être envoyé, ce code correspond à l’état de la requête et dépend de la réussite ou non de celle-ci.\nLes codes de statuts les plus courants que l’on retrouve généralement sur le Web sont :\nCode Définition 200 OK Tout s’est bien passé 201 Created La création de la ressource s’est bien passée (il n’est pas rare que les attributs de la nouvelle ressource soient aussi renvoyés dans la réponse. Dans ce cas, l’URL de cette ressource nouvellement créée est ajoutée via un Header Location) 204 NO Content Même principe que pour la 201, mais cette fois-ci, le contenu de la ressource nouvellement créée ou modifiée n’est pas renvoyé en réponse 304 Not modified Le contenu n’a pas été modifié depuis la dernière fois qu’elle a été mise en cache 400 Bad request La demande n’a pas pu être traitée correctement 401 Unauthorized L’authentification a échoué 403 Forbidden L’accès à cette ressource n’est pas autorisé 404 Not found La ressource n’existe pas 500 Server error Le serveur a rencontré un problème Verbes HTTP (GET, POST, PUT, DELETE) GET\nExemple: Vous souhaitez afficher une liste d’articles sur un blog.\nRequête GET: GET /articles HTTP/1.1\nAction: Le serveur retourne une liste d’articles au format JSON.\nRéponse:\n[ { \"id\": 1, \"title\": \"Article 1\", \"content\": \"Contenu de l'article 1\" }, { \"id\": 2, \"title\": \"Article 2\", \"content\": \"Contenu de l'article 2\" } ]\rPOST\nExemple: Un utilisateur soumet un formulaire pour créer un nouvel article.\nRequête POST: POST /articles HTTP/1.1\nCorps de la requête:\n{ \"title\": \"Nouvel Article\", \"content\": \"Contenu du nouvel article\" }\rAction: Le serveur crée un nouvel article avec les données fournies. Réponse: 201 Created avec l’article créé en retour. PUT\nExemple: Un utilisateur souhaite mettre à jour un article existant.\nRequête PUT: PUT /articles/1 HTTP/1.1\nCorps de la requête:\n{ \"title\": \"Article mis à jour\", \"content\": \"Contenu mis à jour\" }\rAction: Le serveur met à jour l’article avec les nouvelles données\nRéponse: 200 OK avec l’article mis à jour en retour.\nDELETE\nExemple: Un utilisateur souhaite supprimer un article. Requête DELETE: DELETE /articles/1 HTTP/1.1 Action: Le serveur supprime l’article avec l’ID 1. Réponse: 204 No Content (pas de contenu retourné, car la ressource a été supprimée).",
    "description": "Rappel API REST 🌼 Une API REST se doit d’être sans état Stateless. La communication entre le client et le serveur ne doit pas dépendre d’un quelconque contexte provenant du serveur. 🌼 Ainsi, chaque requête doit contenir l’ensemble des informations nécessaires à son traitement. Cela permet au de traiter indifféremment les requêtes de plusieurs clients via de multiples instances de serveurs.\n🌼 Pour chaque réponse renvoyée par l’API, un code doit être envoyé, ce code correspond à l’état de la requête et dépend de la réussite ou non de celle-ci.",
    "tags": [],
    "title": "📘 Révision",
    "uri": "/420-514/intro/revision/index.html"
  },
  {
    "breadcrumb": "Collecte et interprétation de données \u003e Cadriciel (framework) côté serveur : Node.js / express",
    "content": "Introduction à Node.js Historique Avant 2009 le langage (JavaScript) n’était utilisé qu’au côté client et ne peut être exécuté que dans le navigateur (browser) Le code JavaScript était donc cantonné au côté client. Il servait à :\nmanipuler le DOM (Document Object Model), valider des formulaires, créer des animations simples, ajouter de l’interactivité à la page. ⚠️ Aucune possibilité de gérer :\ndes fichiers sur le serveur, une base de données, un système de fichiers ou un réseau. Tout cela était réservé aux langages côté serveur (PHP, Java, Python, C#, etc.).\nEn 2009, Ryan Dahl introduit Node.js, une innovation qui a changé l’histoire de JavaScript. Node.js reprend le moteur V8 de Google Chrome (rapide et optimisé en C++).\nIl l’embarque en dehors du navigateur, créant un nouvel environnement d’exécution JavaScript côté serveur. Avec Node.js, JavaScript peut enfin :\nlire et écrire dans des fichiers, gérer des connexions réseau, dialoguer avec des bases de données, exécuter des applications serveur complètes. 👉 Environnement d’exécution = Node.js (hors navigateur)\n👉 Moteur = V8, mais intégré dans un cadre élargi avec des API système.\nAttention : moteur \u003c\u003e environnement\rMoteur JavaScript : logiciel qui traduit le code JavaScript en instructions machine. (Ex. : V8, SpiderMonkey). Environnement d’exécution : contexte dans lequel s’exécute le code, incluant le moteur + les API disponibles. Dans le navigateur : API DOM, événements, cookies… Dans Node.js : API fichiers, réseau, processus, modules système… Que’est-ce que c’est Node.js ? Node.js est un environnement d’exécution open-source pour créer des applications et outils côté serveur en JavaScript (tel que les APIs), utilisé hors navigateur (directement sur l’ordinateur ou le serveur). Node se distingue par d’excellentes performances, un code uniquement en JavaScript, et un vaste écosystème via NPM, ce qui simplifie le développement d’applications web performantes.\nSource : https://app.pluralsight.com/library/courses/nodejs-express-foundations/description\nAvantages de Node.js Performance : Optimisé pour les applications web évolutives, notamment en temps réel. Un langage unique : JavaScript est utilisé à la fois côté client et serveur. Écosystème NPM : Accès à de nombreuses bibliothèques réutilisables. Installer Node js Pour installer Node Js aller sur le lien suivant : https://nodejs.org/fr/download/package-manager\nExemples de code Hello Node.js : Un exemple simple de serveur web Node.js qui répond “Salut tout le monde”.\nfunction sayHello(name) { console.log(`Hello ${name}!`); } sayHello('students');\rLe système node module 🌍 Les objets globaux : Navigateur vs Node.js Dans le navigateur L’environnement d’exécution est le navigateur. L’objet global est : window. Tous les objets, fonctions ou variables globales sont attachés à window. Exemple :\nconsole.log(window.document); // Accède au DOM window.alert(\"Bonjour depuis le navigateur !\");\rDans Node.js L’environnement d’exécution est Node.js (hors navigateur). L’objet global est : global. Tous les objets et fonctions globales comme : console.log() setTimeout() clearTimeout() setInterval() clearInterval() etc. sont attachés à global.\nExemple :\nglobal.console.log(\"Salut depuis Node.js 👋\"); setTimeout(() =\u003e { global.console.log(\"Ceci s’exécute après 1 seconde\"); }, 1000);\r⚠️ Dans Node.js, il n’y a pas de window ni de document → pas de DOM.\nNode.js fournit aussi un alias globalThis, qui est un standard JavaScript moderne : js\rglobalThis.console.log(\"Salut avec globalThis\");\r👉 Ainsi, on a :\nNavigateur : window === globalThis ✅ Node.js : global === globalThis ✅ en résumé\nContexte Objet global Exemple Navigateur window window.alert(\"Bonjour\") Node.js global global.console.log(\"Salut\") Standard (les deux) globalThis globalThis.setTimeout(...) 📦 Les modules en Node.js En node chaque fichier est un module et les fonctions ainsi que les variables définies dans ce fichier ne sont disponible qu’à l’interieur de ce module. Cela permet :\nd’organiser le code en plusieurs fichiers, d’éviter la duplication, de partager des fonctionnalités entre projets. Types de modules dans Node.js Modules internes (built-in)\nDéjà fournis avec Node.js.\nExemples :\nfs (fichiers), http (serveur web), path (chemins de fichiers), os (système d’exploitation). const fs = require('fs'); fs.writeFileSync('test.txt', 'Bonjour Node.js !');\rModules locaux (créés par nous)\nNos propres fichiers .js. Exemple : // fichier math.js function addition(a, b) { return a + b; } module.exports = addition;\r// fichier app.js const addition = require('./math'); console.log(addition(2, 3)); // 5 Modules tiers (installés avec npm)\nModules créés par la communauté. Exemple : express, lodash, mongoose. npm install express\rconst express = require('express'); const app = express(); app.get('/', (req, res) =\u003e res.send('Hello Express 🚀')); app.listen(3000);\r📦Systèmes de modules a) CommonJS (historiquement utilisé par Node.js) Utilise require() pour importer. Utilise module.exports pour exporter. // math.js module.exports = { addition: (a, b) =\u003e a + b, multiplication: (a, b) =\u003e a * b };\r// app.js const math = require('./math'); console.log(math.addition(2, 3));\rb) ES Modules (standard moderne JavaScript) Utilise import / export. Nécessite d’ajouter \"type\": \"module\" dans package.json. // math.mjs export function addition(a, b) { return a + b; }\r// app.mjs import { addition } from './math.mjs'; console.log(addition(4, 5));\rVoici un résumé comparatif\nType de module Exemple import Exemple export CommonJS (par défaut Node.js) const x = require('./fichier') module.exports = ... ES Module (standard moderne) import x from './fichier.js' export default ... ou export function ... Utilisation des Modules Les modules permettent d’organiser et réutiliser le code. Vous pouvez créer et importer des modules en utilisant require().\nExemple de module :\nexports.area = function (width) { return width * width; }; exports.perimeter = function (width) { return 4 * width; };\rOu\n// dans mathOperations.js function add(a, b) { return a + b; } function subtract(a, b) { return a - b; } function multiply(a, b) { return a * b; } function divide(a, b) { if (b === 0) { throw new Error('Division par zéro'); } return a / b; } // Export des fonctions pour les rendre disponibles dans d'autres fichiers module.exports = { add, subtract, multiply, divide };\rExemple d’un simple serveur\nconst http = require(\"http\"); const hostname = \"127.0.0.1\"; const port = 8000; const server = http.createServer((req, res) =\u003e { res.writeHead(200, { \"Content-Type\": \"text/plain\" }); res.end(\"Salut tout le monde\"); }); server.listen(port, hostname, () =\u003e { console.log(`Le serveur tourne à l'adresse http:\\\\${hostname}:${port}/`); });\rGestion des paquets avec npm Initialiser un projet : npm init -y Installer un module : npm install express Sauvegarder en dépendances dans package.json. Scripts personnalisés :\n\"scripts\": { \"start\": \"node app.js\", \"dev\": \"nodemon app.js\" }\rLire et écrire dans des fichiers Node.js fournit le module fs (File System) :\n// files.js const fs = require('fs'); // Écriture fs.writeFileSync('message.txt', 'Bonjour Node.js !'); // Lecture const data = fs.readFileSync('message.txt', 'utf8'); console.log(\"Contenu du fichier :\", data);\rAsynchronisme en Node.js Node.js excelle dans les opérations asynchrones (lecture de fichiers, accès réseau).\n// async.js const fs = require('fs'); fs.readFile('message.txt', 'utf8', (err, data) =\u003e { if (err) { console.error('Error reading the file:', err); return; } console.log(\"Lecture asynchrone :\", data); }); console.log(\"Cette ligne s’affiche avant la lecture du fichier !\");\r👉 Résultat : la lecture se fait en arrière-plan, pendant que le reste du code continue à s’exécuter.\nGestion des événements (EventEmitter) Node.js est basé sur un modèle événementiel.\nconst EventEmitter = require('events'); const emitter = new EventEmitter(); emitter.on('salut', (nom) =\u003e { console.log(`Bonjour ${nom} !`); }); emitter.emit('salut', 'Alice');\r👉 Utile pour créer des systèmes réactifs (logs, notifications, etc.).\nLiens utiles : Site de Node.js :\nNode.js — Exécuter du JavaScript partout\nDocumentation officielle de Node.js\nFormation : https://app.pluralsight.com/library/courses/nodejs-express-foundations",
    "description": "Introduction à Node.js Historique Avant 2009 le langage (JavaScript) n’était utilisé qu’au côté client et ne peut être exécuté que dans le navigateur (browser) Le code JavaScript était donc cantonné au côté client. Il servait à :\nmanipuler le DOM (Document Object Model), valider des formulaires, créer des animations simples, ajouter de l’interactivité à la page. ⚠️ Aucune possibilité de gérer :\ndes fichiers sur le serveur, une base de données, un système de fichiers ou un réseau. Tout cela était réservé aux langages côté serveur (PHP, Java, Python, C#, etc.).",
    "tags": [],
    "title": "📘 NodeJs",
    "uri": "/420-514/nodejsframeworkexpress/nodejs/index.html"
  },
  {
    "breadcrumb": "Collecte et interprétation de données \u003e Cadriciel (framework) côté serveur : Node.js / express",
    "content": "Introduction à Express Express est un framework web minimaliste pour Node.js, permettant de créer des applications web robustes et modulaires. Il facilite la gestion des routes, le rendu de vues dynamiques, et l’intégration de middlewares pour diverses tâches comme les sessions ou l’authentification.\nExemple d’Express const express = require(\"express\"); const app = express(); const port = 3000; app.get(\"/\", (req, res) =\u003e { res.send(\"Hello World!\"); }); app.listen(port, () =\u003e { console.log(`Application à l'écoute sur le port ${port}!`); });\rSource : https://app.pluralsight.com/library/courses/nodejs-express-foundations/description\nMiddleware et gestion des erreurs Les middlewares sont des fonctions intermédiaires dans le traitement des requêtes. Ils sont essentiels pour gérer les fichiers statiques, les sessions, les erreurs, etc.\nSource : https://app.pluralsight.com/library/courses/nodejs-express-foundations/description\nconst express = require(\"express\"); const app = express(); let middlewareFunction = (req, res, next) =\u003e { // Logique du middleware next(); }; app.use(middlewareFunction); app.listen(3000);\rUn middleware dans Node.js est une fonction qui a accès à l’objet de requête (req), l’objet de réponse (res), et à la fonction next() dans le cycle de traitement des requêtes HTTP.\nLes middlewares permettent de modifier, d’analyser, d’intercepter ou de répondre aux requêtes avant qu’elles n’atteignent les routes finales. Ils sont très utiles pour ajouter des fonctionnalités transversales (comme l’authentification, la gestion des erreurs, le logging, etc.) sans modifier chaque route de l’application.\nFonctionnement d’un middleware : Un middleware est une fonction qui peut faire les choses suivantes :\nExécuter du code. Modifier l’objet de requête (req) ou de réponse (res). Terminer le cycle de la requête/réponse (par exemple en renvoyant une réponse au client). Appeler la fonction next() pour passer la main au middleware suivant dans la chaîne. Exemple de middleware simple : Voici un exemple basique d’un middleware dans Express :\napp.use((req, res, next) =\u003e { console.log('Middleware exécuté pour chaque requête'); next(); // Passe la main au middleware ou à la route suivante });\rDans cet exemple :\nCe middleware s’exécutera pour toutes les requêtes reçues par l’application. Il affiche un message dans la console et appelle next() pour permettre à Express de continuer avec les middlewares suivants ou les routes définies. Types de middlewares dans Express : Middlewares d’application :\nCes middlewares sont associés à l’instance de l’application (app) et s’exécutent pour toutes les routes ou pour des routes spécifiques.\nExemple :\napp.use((req, res, next) =\u003e { console.log('Ceci est un middleware d\\\\'application'); next(); });\rMiddlewares spécifiques à une route :\nIls s’appliquent à une ou plusieurs routes spécifiques.\nExemple :\napp.get('/user', (req, res, next) =\u003e { console.log('Middleware pour la route /user'); next(); }, (req, res) =\u003e { res.send('Profil utilisateur'); });\rMiddlewares intégrés :\nExpress fournit des middlewares intégrés comme express.json() ou express.urlencoded() pour parser les corps des requêtes.\nExemple :\napp.use(express.json());\rMiddlewares tiers :\nVous pouvez installer des middlewares fournis par la communauté pour des tâches spécifiques, comme la gestion des sessions, la sécurité, etc.\nExemple : morgan pour le logging des requêtes HTTP.\nconst morgan = require('morgan'); app.use(morgan('dev'));\rMiddlewares de gestion des erreurs :\nUn middleware de gestion des erreurs prend quatre paramètres : (err, req, res, next) et est utilisé pour capturer les erreurs et renvoyer des réponses appropriées.\nExemple :\napp.use((err, req, res, next) =\u003e { console.error(err.stack); res.status(500).send('Quelque chose s\\'est mal passé !'); });\rPourquoi utiliser des middlewares ? Modularité : Ils permettent d’ajouter des fonctionnalités réutilisables, comme la gestion des sessions, sans toucher à chaque route de l’application. Composabilité : Les middlewares peuvent être chaînés pour créer un pipeline de traitement des requêtes. Réutilisabilité : Vous pouvez créer des middlewares personnalisés qui peuvent être réutilisés à travers plusieurs routes ou applications. Utilisation des bases de données Node.js prend en charge plusieurs bases de données comme MongoDB. Pour connecter votre application à une base de données, vous devez installer le pilote correspondant.\nExemple MongoDB :\nconst MongoClient = require(\"mongodb\").MongoClient; MongoClient.connect(\"mongodb://localhost:27017/animals\", (err, client) =\u003e { if (err) throw err; let db = client.db(\"animals\"); db.collection(\"mammals\").find().toArray((err, result) =\u003e { if (err) throw err; console.log(result); client.close(); }); });\rGestion du logging Autre middlewares pour la gestion du logging, ainsi que pour servir des fichiers statiques comme des pages HTML avec Express.\nAjouter des middlewares pour le logging Les middlewares sont des fonctions qui ont accès à l’objet request (req), l’objet response (res) et à la fonction next dans le cycle de requête-réponse. Ils sont utiles pour intercepter et gérer des requêtes avant qu’elles ne parviennent aux routes définies.\nAjouter un middleware de logging Un middleware de logging peut enregistrer chaque requête reçue par le serveur. Ajoutez le code suivant au début de votre fichier index.js :\nconst express = require('express'); const app = express(); const port = 3000; // Middleware de logging app.use((req, res, next) =\u003e { console.log(`${req.method} ${req.url}`); next(); });\rServir des fichiers statiques Pour servir des fichiers statiques comme des pages HTML, CSS, ou des images, Express offre une méthode simple. Créez un dossier public dans votre projet pour stocker ces fichiers.\nCréer un Dossier public Créez le dossier public à la racine de votre projet :\nmkdir public\rAjoutez un fichier HTML dans le dossier public :\nCréez un fichier index.html dans le dossier public avec le contenu suivant :\n\u003c!DOCTYPE html\u003e \u003chtml lang=\"fr\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003ePage d'accueil\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eBienvenue sur mon site!\u003c/h1\u003e \u003cp\u003eCeci est une page HTML servie par Express.\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e\rConfigurer Express pour servir les fichiers statiques Ajoutez le code suivant à votre index.js pour permettre à Express de servir les fichiers du dossier public :\n// Servir des fichiers statiques app.use(express.static('public'));\rTester Testez le middleware de logging : Lancez votre serveur avec node index.js et accédez à différentes routes (par exemple, / ou /info). Vous devriez voir les requêtes enregistrées dans le terminal.\nTestez le middleware de gestion des erreurs : Pour simuler une erreur, vous pouvez créer une route qui lève une exception :\napp.get('/cause-error', (req, res) =\u003e { throw new Error('Erreur simulée!'); });\rEn accédant à cette route (GET \u003chttp://localhost:3000/cause-error\u003e), vous verrez le message d’erreur personnalisé.\nTestez la servitude des fichiers statiques : Accédez à http://localhost:3000/ dans votre navigateur. Vous devriez voir la page HTML créée dans public/index.html.\nLe Fichier index.js Voici le code final du fichier index.js :\nconst express = require('express'); const app = express(); const port = 3000; // Middleware de logging app.use((req, res, next) =\u003e { console.log(`${req.method} ${req.url}`); next(); }); // Servir des fichiers statiques app.use(express.static('public')); // Route de base app.get('/', (req, res) =\u003e { res.send('Bienvenue sur mon serveur Express!'); }); // Route pour afficher un message personnalisé app.get('/hello/:name', (req, res) =\u003e { const name = req.params.name; res.send(`Bonjour, ${name}!`); }); // Route qui renvoie les informations sur le serveur app.get('/info', (req, res) =\u003e { res.json({ version: '1.0.0', description: 'Ceci est un serveur simple utilisant Express.js', }); }); // Route pour simuler une erreur app.get('/cause-error', (req, res) =\u003e { throw new Error('Erreur simulée!'); }); // Middleware de gestion des erreurs app.use((err, req, res, next) =\u003e { console.error(err.stack); res.status(500).send('Quelque chose s\\'est mal passé!'); }); // Démarrer le serveur app.listen(port, () =\u003e { console.log(`Serveur en écoute sur \u003chttp://localhost\u003e:${port}`); });\rUtiliser la librairie de journalisation Winston Winston est une bibliothèque de journalisation (logging) populaire pour Node.js. Elle permet aux développeurs de capturer, formater, et gérer des logs dans différentes sorties (fichiers, console, bases de données, etc.). Winston est flexible et extensible, ce qui en fait un choix idéal pour les projets nécessitant une gestion fine des logs, notamment pour le débogage, la surveillance et le suivi des événements.\nPrincipales fonctionnalités de Winston Multiples Transports : Winston peut envoyer des logs vers différents supports appelés “transports” (fichiers, bases de données, systèmes de journalisation distants, etc.). Niveaux de Log : Il prend en charge différents niveaux de log (ex: error, warn, info, debug) pour filtrer et gérer les logs en fonction de leur importance. Source : app.pluralsight.com/\nFormats de Log : Winston permet de formater les messages de log en JSON, en texte, ou en tout autre format personnalisé. Configuration Flexible : Il est possible de configurer plusieurs loggers, chacun avec ses propres niveaux de log, formats et transports. Installation de Winston Pour installer Winston dans votre projet Node.js, utilisez la commande suivante :\nnpm install winston\rExemple d’utilisation de Winston Voici un exemple simple d’utilisation de Winston pour configurer un logger qui envoie les logs à la console et à un fichier.\nconst winston = require('winston'); // Configuration du logger const logger = winston.createLogger({ // Le niveau minimum de log est défini à info. // Cela signifie que tous les logs de niveau info et plus élevés (ex: warn, error) seront capturés. level: 'info', // Niveau minimum de log (info, warn, error, etc.) // Les logs sont formatés en JSON et incluent un timestamp pour chaque message. format: winston.format.combine( winston.format.timestamp(), winston.format.json() // Format des logs en JSON ), // Le logger est configuré avec deux transports : la console et un fichier app.log transports: [ new winston.transports.Console(), // Log vers la console new winston.transports.File({ filename: 'logs/app.log' }) // Log vers un fichier ] }); // Exemple de logs logger.info('L\\'application a démarré'); logger.warn('Attention, ceci est un avertissement'); logger.error('Une erreur est survenue');\rExemple du code complet :\nimport express from 'express' import { join } from 'node:path' import { createLogger, format, transports } from 'winston' const app = express() const logger = createLogger({ level: 'info', format: format.combine( format.timestamp(), format.json() ), transports: [ new transports.Console(), new transports.File({ filename: 'logs/app.log' }) ] }) const logAll = function(request, response, next) { logger.info(`L'application a démarré : ${request.url}`) logger.warn('Attention, ceci est un avertissement'); logger.error('Une erreur est survenue'); next() } app.use(express.json()) app.use(express.static(join(process.cwd(), 'src', 'public'))) app.use(logAll)\rUtilisations : Débogage : Winston est souvent utilisé pour capturer des erreurs et des messages de débogage pendant le développement. Surveillance en Production : En production, Winston permet de centraliser les logs pour surveiller le bon fonctionnement de l’application et diagnostiquer les problèmes. Audit et Traçabilité : Winston peut être configuré pour capturer des logs spécifiques pour l’audit, la sécurité ou la traçabilité des événements critiques. Liens utiles : Formation : https://app.pluralsight.com/library/courses/nodejs-express-foundations\nArticle : Guide Winston\nDocumentation : Github Winston",
    "description": "Introduction à Express Express est un framework web minimaliste pour Node.js, permettant de créer des applications web robustes et modulaires. Il facilite la gestion des routes, le rendu de vues dynamiques, et l’intégration de middlewares pour diverses tâches comme les sessions ou l’authentification.\nExemple d’Express const express = require(\"express\"); const app = express(); const port = 3000; app.get(\"/\", (req, res) =\u003e { res.send(\"Hello World!\"); }); app.listen(port, () =\u003e { console.log(`Application à l'écoute sur le port ${port}!`); });",
    "tags": [],
    "title": "📘 Express",
    "uri": "/420-514/nodejsframeworkexpress/express/index.html"
  },
  {
    "breadcrumb": "Collecte et interprétation de données \u003e Cadriciel (framework) côté serveur : Node.js / express",
    "content": "1. Installer Node.js Assurez-vous que Node.js est installé sur votre machine. Vous pouvez le télécharger depuis le site officiel de Node.js.\nVérifier l’installation : node -v npm -v\rExécuter un script : // hello.js console.log(\"Hello Node.js 🚀\");\rPuis :\nnode hello.js\r2. Initialiser un nouveau projet Node.js Ouvrez votre terminal et créez un nouveau dossier pour votre projet. Accédez à ce dossier, puis exécutez la commande suivante pour initialiser un nouveau projet Node.js :\nmkdir mon-projet-express cd mon-projet-express npm init -y\rLe drapeau -y accepte les valeurs par défaut pour toutes les options, créant ainsi un fichier package.json de base.\n3. Installer Express.js Installez Express.js en tant que dépendance dans votre projet :\nnpm install express --save Express facilite la gestion des routes et des réponses.\n4. Configurer le serveur Express Créez un fichier index.js dans le dossier racine de votre projet, puis ajoutez-y le code suivant pour configurer un serveur de base avec Express.js :\nconst express = require('express'); const app = express(); const port = 3000; app.get('/', (req, res) =\u003e { res.send('Hello, World!'); }); app.listen(port, () =\u003e { console.log(`Serveur en écoute sur \u003chttp://localhost\u003e:${port}`); });\r5. Démarrer le serveur Vous pouvez maintenant démarrer votre serveur en exécutant la commande suivante dans votre terminal :\nnode index.js\rCela démarrera le serveur et affichera Serveur en écoute sur http://localhost:3000. Vous pouvez accéder à cette URL via votre navigateur pour voir le message “Hello, World!”.\n6. Installer nodemon pour un développement plus efficace Pour un développement plus pratique, vous pouvez installer nodemon. Cet outil redémarre automatiquement le serveur à chaque fois que vous modifiez le code :\nnpm install -g nodemon\rEnsuite, au lieu de lancer votre serveur avec node index.js, utilisez :\nnodemon index.js\rSi vous rencontrez cette erreur sur Windows :\nVous pouvez la restriction de la politique de sécurité avec la commande suivante :\nSet-ExecutionPolicy RemoteSigned -Scope CurrentUser\rOn peut aussi démarrer le serveur node en mode watch-path pour une mise à jour immédiate à chaque fois un fichier dans le dossier racine change. Il faut donc déplacer votre fichier dans un dossier src :\nnode --watch-path=./src .\\src\\index.js\r7. Structurer votre projet Il est recommandé de structurer votre projet de manière à ce qu’il soit facilement maintenable :\nindex.js : Point d’entrée de l’application. routes/ : Contient les fichiers de routage. controllers/ : Logique métier. models/ : Modèles de données si vous utilisez une base de données. public/ : Contient les fichiers statiques comme les CSS, images, etc. views/ : Si vous utilisez un moteur de template comme EJS ou Pug. 8. Ajouter des middlewares Vous pouvez ajouter des middlewares pour gérer les requêtes, comme le parsing des corps de requêtes JSON :\napp.use(express.json()); app.use(express.urlencoded({ extended: true }));\r9. Ajouter des routes supplémentaires Commençons par ajouter des routes supplémentaires dans votre application. Pour une meilleure organisation, nous allons créer un dossier routes/ où nous stockerons les différents fichiers de routes.\nconst express = require('express'); const app = express(); const port = 3000; // Route de base qui renvoie un message de bienvenue app.get('/', (req, res) =\u003e { res.send('Bienvenue sur mon serveur Express!'); }); // Route pour afficher un message personnalisé app.get('/hello/:name', (req, res) =\u003e { const name = req.params.name; res.send(`Bonjour, ${name}!`); }); // Route qui renvoie les informations sur le serveur app.get('/info', (req, res) =\u003e { res.json({ version: '1.0.0', description: 'Ceci est un serveur simple utilisant Express.js', }); }); // Démarrer le serveur app.listen(port, () =\u003e { console.log(`Serveur en écoute sur \u003chttp://localhost\u003e:${port}`); });\r9.1 Créer un fichier de routes Créez un fichier routes/users.js :\nconst express = require('express'); const router = express.Router(); // Route pour récupérer tous les utilisateurs router.get('/', (req, res) =\u003e { res.send('Liste des utilisateurs'); }); // Route pour récupérer un utilisateur par ID router.get('/:id', (req, res) =\u003e { res.send(`Utilisateur avec ID ${req.params.id}`); }); module.exports = router;\r9.2 Utiliser les routes dans l’application principale Modifiez votre fichier index.js pour inclure ces nouvelles routes :\nconst express = require('express'); const app = express(); const port = 3000; const userRoutes = require('./routes/users'); app.use(express.json()); app.use(express.urlencoded({ extended: true })); // Route de base app.get('/', (req, res) =\u003e { res.send('Hello, World!'); }); // Utiliser les routes définies dans le fichier users.js app.use('/users', userRoutes); app.listen(port, () =\u003e { console.log(`Serveur en écoute sur \u003chttp://localhost\u003e:${port}`); });\r10. Accès aux fichiers const fs = require('fs'); // Écriture fs.writeFileSync('data.txt', 'Hello Node!'); // Lecture const data = fs.readFileSync('data.txt', 'utf8'); console.log(data);\r11. Asynchrone et promises const fs = require('fs').promises; async function readFile() { try { const data = await fs.readFile('data.txt', 'utf8'); console.log(data); } catch (err) { console.error(err); } } readFile();",
    "description": "1. Installer Node.js Assurez-vous que Node.js est installé sur votre machine. Vous pouvez le télécharger depuis le site officiel de Node.js.\nVérifier l’installation : node -v npm -v\rExécuter un script : // hello.js console.log(\"Hello Node.js 🚀\");\rPuis :\nnode hello.js\r2. Initialiser un nouveau projet Node.js Ouvrez votre terminal et créez un nouveau dossier pour votre projet. Accédez à ce dossier, puis exécutez la commande suivante pour initialiser un nouveau projet Node.js :",
    "tags": [],
    "title": "🧪 Laboratoire : Commencer avec Node.js et Express.js",
    "uri": "/420-514/nodejsframeworkexpress/lab/index.html"
  },
  {
    "breadcrumb": "Collecte et interprétation de données \u003e Cadriciel (framework) côté serveur : Node.js / express",
    "content": "Partie 1 : Ajouter des middlewares pour la gestion des erreurs et le logging Ajouter un middleware de logging\nCréez un middleware qui enregistre chaque requête reçue par le serveur. Implémentez le code suivant au début de votre fichier index.js : const express = require('express'); const app = express(); const port = 3000; // Middleware de logging app.use((req, res, next) =\u003e { console.log(`${req.method} ${req.url}`); next(); });\rAjouter un middleware de gestion des erreurs\nCréez un middleware pour intercepter les erreurs et envoyer une réponse appropriée. Placez ce middleware à la fin de toutes vos routes dans index.js : // Middleware de gestion des erreurs app.use((err, req, res, next) =\u003e { console.error(err.stack); res.status(500).send('Une erreur est survenue!'); });\rPartie 2 : Servir des fichiers statiques Créer un Dossier public\nCréez un dossier public à la racine de votre projet avec la commande suivante : mkdir public\rAjouter un fichier HTML dans le dossier public\nCréez un fichier index.html dans le dossier public avec le contenu suivant : \u003c!DOCTYPE html\u003e \u003chtml lang=\"fr\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003ePage d'accueil\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eBienvenue sur mon site!\u003c/h1\u003e \u003cp\u003eCeci est une page HTML servie par Express.\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e\rConfigurer Express pour servir les fichiers statiques\nAjoutez le code suivant dans votre fichier index.js pour permettre à Express de servir les fichiers du dossier public : // Servir des fichiers statiques app.use(express.static('public'));\rPartie 3 : Utiliser la librairie de journalisation Winston Installer Winston\nInstallez la librairie Winston en exécutant la commande suivante dans votre terminal : npm install winston\rConfigurer Winston\nAjoutez le code suivant dans votre fichier index.js pour configurer Winston et l’intégrer avec Express pour gérer les logs : const winston = require('winston'); // Configuration du logger avec Winston const logger = winston.createLogger({ level: 'info', format: winston.format.combine( winston.format.timestamp(), winston.format.json() ), transports: [ new winston.transports.Console(), new winston.transports.File({ filename: 'logs/app.log' }) ] }); // Middleware de logging utilisant Winston app.use((req, res, next) =\u003e { logger.info(`${req.method} ${req.url}`); next(); });\rPartie 4 : Tester les améliorations Test du middleware de logging Lancez votre serveur avec node index.js. Accédez à différentes routes (par exemple, / ou /info) et vérifiez que les requêtes sont enregistrées dans le terminal et dans le fichier logs/app.log. Test du Middleware de Gestion des Erreurs Créez une route qui lève une exception pour simuler une erreur :\napp.get('/cause-error', (req, res) =\u003e { throw new Error('Erreur simulée!'); });\rAccédez à cette route via GET \u003chttp://localhost:3000/cause-error\u003e et observez le message d’erreur personnalisé.\nTest de la Servitude des Fichiers Statiques Accédez à http://localhost:3000/ dans votre navigateur pour voir la page HTML servie par Express. Partie 5 : Fichier index.js complet Voici un exemple complet après l’ajout des middlewares et Winston :\nconst express = require('express'); const winston = require('winston'); const app = express(); const port = 3000; // Configuration du logger avec Winston const logger = winston.createLogger({ level: 'info', format: winston.format.combine( winston.format.timestamp(), winston.format.json() ), transports: [ new winston.transports.Console(), new winston.transports.File({ filename: 'logs/app.log' }) ] }); // Middleware de logging utilisant Winston app.use((req, res, next) =\u003e { logger.info(`${req.method} ${req.url}`); next(); }); // Servir des fichiers statiques app.use(express.static('public')); // Route de base app.get('/', (req, res) =\u003e { res.send('Bienvenue sur mon serveur Express!'); }); // Route pour afficher un message personnalisé app.get('/hello/:name', (req, res) =\u003e { const name = req.params.name; res.send(`Bonjour, ${name}!`); }); // Route qui renvoie les informations sur le serveur app.get('/info', (req, res) =\u003e { res.json({ version: '1.0.0', description: 'Ceci est un serveur simple utilisant Express.js', }); }); // Route pour simuler une erreur app.get('/cause-error', (req, res) =\u003e { throw new Error('Erreur simulée!'); }); // Middleware de gestion des erreurs app.use((err, req, res, next) =\u003e { logger.error(err.stack); res.status(500).send('Une erreur est survenue!'); }); // Démarrer le serveur app.listen(port, () =\u003e { console.log(`Serveur en écoute sur \u003chttp://localhost\u003e:${port}`); });\rRésultats attendus Logging: Toutes les requêtes HTTP seront enregistrées dans la console et dans le fichier logs/app.log. Gestion des erreurs: En cas d’erreur, un message d’erreur approprié sera affiché, et les détails seront enregistrés dans les logs. Servitude de fichiers statiques: La page HTML située dans le dossier public sera servie par Express lorsque l’on accède à l’URL racine du serveur.",
    "description": "Partie 1 : Ajouter des middlewares pour la gestion des erreurs et le logging Ajouter un middleware de logging\nCréez un middleware qui enregistre chaque requête reçue par le serveur. Implémentez le code suivant au début de votre fichier index.js : const express = require('express'); const app = express(); const port = 3000; // Middleware de logging app.use((req, res, next) =\u003e { console.log(`${req.method} ${req.url}`); next(); });\rAjouter un middleware de gestion des erreurs\nCréez un middleware pour intercepter les erreurs et envoyer une réponse appropriée. Placez ce middleware à la fin de toutes vos routes dans index.js : // Middleware de gestion des erreurs app.use((err, req, res, next) =\u003e { console.error(err.stack); res.status(500).send('Une erreur est survenue!'); });\rPartie 2 : Servir des fichiers statiques Créer un Dossier public",
    "tags": [],
    "title": "🧪 Laboratoire : Gestion des Erreurs et Logging",
    "uri": "/420-514/nodejsframeworkexpress/lab2/index.html"
  },
  {
    "breadcrumb": "Collecte et interprétation de données \u003e Requêtes HTTP et format de données",
    "content": "Le protocole HTTP HTTP (HyperText Transfer Protocol) est le protocole qui permet d’échanger des données sur le Web.\nIl fonctionne selon un modèle client-serveur : c’est toujours le client (navigateur) qui envoie une requête, et le serveur qui répond.\nHTTP est utilisé pour récupérer différentes ressources :\ndocuments HTML, feuilles de style (CSS), images, vidéos, scripts, etc. Un document web complet est construit en combinant tous ces sous-documents envoyés par le serveur.\nParties d’une Requête HTTP URL (Uniform Resource Locator): L’adresse de la ressource demandée.\nExemple: https://api.example.com/users/123 Cette URL accède à la ressource utilisateur avec l’ID 123. Méthode HTTP: Le verbe HTTP utilisé pour la requête (GET, POST, etc.).\nEn-têtes (Headers): Informations supplémentaires sur la requête.\nCorps (Body): Contenu de la requête (souvent utilisé avec POST et PUT).\nExemple:\n{ \"username\": \"johndoe\", \"email\": \"john@example.com\" }\rLe corps contient les données envoyées au serveur pour créer ou mettre à jour une ressource.\n1. URL Le chemin de la ressource à extraire correspond à l’URL simplifiée de la ressource, dont on a retiré les éléments déjà implicites dans le contexte, comme le protocole (http://), le nom de domaine (ex. .mozilla.org) ou encore le port TCP par défaut (ex. 80).\n2. Méthodes HTTP (GET, POST, PUT, DELETE) Une méthode HTTP est une instruction envoyée par le client au serveur pour préciser l’action à effectuer sur une ressource. Le plus souvent, il s’agit d’un verbe comme GET (récupérer une ressource) ou POST (envoyer des données, par exemple le contenu d’un formulaire). Il existe aussi d’autres méthodes comme OPTIONS ou HEAD, qui permettent d’effectuer des opérations spécifiques selon le contexte. - Exemple: POST /users HTTP/1.1 - Cette méthode indique que la requête envoie des données pour créer un nouvel utilisateur.\n3. En-têtes (Headers) Ce sont des paires clé-valeur qui fournissent des informations supplémentaires sur la requête.\nObligatoires : Host (nom du serveur). Optionnels : User-Agent, Content-Type, Accept, Authorization, etc. 👉 Exemple :\nHost: www.exemple.com\rUser-Agent: Mozilla/5.0\rAccept: text/html\rLes en-têtes optionnels servent à transmettre des informations complémentaires destinées au serveur, afin de préciser ou d’adapter le traitement de la requête.\n👉 Exemple:\n```\rContent-Type: application/json\rAuthorization: Bearer your-token-here\r```\rSachant que : Content-Type indique que le corps de la requête est en format JSON. Authorization envoie un token d’authentification. Exemples d’entêtes : En-tête Exemple Rôle Host Host: www.exemple.com Indique le nom de domaine du serveur demandé (obligatoire en HTTP/1.1). User-Agent User-Agent: Mozilla/5.0 Fournit des infos sur le client (navigateur, OS, version). Accept Accept: text/html, application/json Indique les formats de réponse que le client peut accepter. Content-Type Content-Type: application/json Spécifie le format des données envoyées au serveur. Content-Length Content-Length: 256 Taille du corps de la requête (en octets). Authorization Authorization: Bearer \u003ctoken\u003e Transmet un jeton ou identifiant pour authentifier le client. Cookie Cookie: sessionId=xyz Envoie des données de session ou de suivi au serveur. Cache-Control Cache-Control: no-cache Indique comment gérer la mise en cache des ressources. Referer Referer: https://google.com Indique la page d’où vient la requête. Accept-Language Accept-Language: fr-FR Spécifie la langue préférée du client. Filtres d’Origines des Requêtes (CORS) CORS (Cross-Origin Resource Sharing) : Un mécanisme qui permet au serveur de spécifier quelles origines (domaines) peuvent accéder à ses ressources.\nExemple: Si une application JavaScript sur https://frontend.example.com veut faire une requête vers https://api.example.com, mais que CORS n’est pas configuré, le navigateur bloquera la requête.\nSolution avec CORS: Le serveur https://api.example.com peut configurer CORS pour autoriser les requêtes provenant de https://frontend.example.com :\nconst cors = require('cors'); app.use(cors({ origin: '\u003chttps://frontend.example.com\u003e' }));\rOn peut aussi spécifier les méthodes qui sont autorisées sur cette route et headers qu’on peut ajouter à notre requête :\nconst express = require('express'); const cors = require('cors'); const app = express(); app.use(cors({ origin: ['http://example.com', 'https://api.example.com'], methods: ['GET', 'POST', 'PUT', 'DELETE'], allowedHeaders: ['Content-Type', 'Authorization'] }));\r4. Corps Sert à transmettre des données au serveur (ex. formulaire HTML, JSON, fichier).\nPrésent uniquement dans certaines méthodes (ex. POST, PUT).\nExemple : POST /api/users HTTP/1.1 Host: api.exemple.com Content-Type: application/json Content-Length: 45 { \"nom\": \"Alice\", \"email\": \"alice@mail.com\" }\rFormats de Données : JSON et XML JSON (JavaScript Object Notation) : Un format de données léger, facile à lire pour les humains et à analyser par les machines.\nExemple :\n{ \"name\": \"John Doe\", \"age\": 30, \"city\": \"New York\" }\rUtilisation: JSON est couramment utilisé pour les API RESTful, où les données sont échangées entre le client et le serveur sous forme de paires clé-valeur.\nXML (eXtensible Markup Language) : Un format de données structuré utilisant des balises, similaire au HTML.\nExemple :\n\u003cperson\u003e \u003cname\u003eJohn Doe\u003c/name\u003e \u003cage\u003e30\u003c/age\u003e \u003ccity\u003eNew York\u003c/city\u003e \u003c/person\u003e\rUtilisation: XML est utilisé dans des systèmes plus anciens ou pour des échanges de données dans des environnements nécessitant un balisage strict, comme les services SOAP.",
    "description": "Le protocole HTTP HTTP (HyperText Transfer Protocol) est le protocole qui permet d’échanger des données sur le Web.\nIl fonctionne selon un modèle client-serveur : c’est toujours le client (navigateur) qui envoie une requête, et le serveur qui répond.\nHTTP est utilisé pour récupérer différentes ressources :\ndocuments HTML, feuilles de style (CSS), images, vidéos, scripts, etc. Un document web complet est construit en combinant tous ces sous-documents envoyés par le serveur.",
    "tags": [],
    "title": "📘 Requêtes HTTP",
    "uri": "/420-514/httprequestdataformat/httprequest/index.html"
  },
  {
    "breadcrumb": "Collecte et interprétation de données \u003e Requêtes HTTP et format de données",
    "content": "🔹 Définition Une requête asynchrone est une requête qui ne bloque pas l’exécution du programme pendant l’attente de la réponse. Le programme peut continuer à effectuer d’autres tâches, et traite la réponse uniquement lorsqu’elle est disponible (via un mécanisme de notification, callback, promesse, ou événement).\n🔹 Pourquoi asynchrone ? Performance : éviter qu’une application soit bloquée par une opération lente (accès réseau, lecture disque). Scalabilité : permettre à un serveur de gérer plusieurs connexions simultanées. Expérience utilisateur : garder les interfaces réactives (ex. : chargement d’un contenu sans recharger toute la page). 🔹 Cas d’utilisation Web : AJAX (Asynchronous JavaScript and XML) pour charger des données sans recharger la page. Applications mobiles : appel à une API distante tout en maintenant l’interface fluide. Systèmes distribués : communication entre microservices. Base de données : requêtes envoyées en tâche de fond. 🔹 Comparaison avec les requêtes synchrones Synchrone : le programme attend la fin de la requête avant de continuer → simple, mais bloquant. Asynchrone : le programme envoie la requête, continue d’exécuter d’autres instructions, puis gère la réponse quand elle arrive. 🔹 Modes de gestion Callbacks : fonction appelée quand la réponse arrive. Promesses : objet représentant une valeur future (résolue ou rejetée). async/await : syntaxe moderne pour écrire du code asynchrone de manière lisible. Événements/observables : modèle réactif, utile pour gérer des flux continus de données. 🔹 Exemple générique (pseudo-code) print(\"Début du programme\")\renvoyer requête asynchrone à l’API:\rquand la réponse est reçue:\rafficher(\"Réponse :\", données)\rprint(\"Fin du programme (la réponse arrivera plus tard)\")\r👉 Résultat : le programme affiche “Début” et “Fin” immédiatement, puis seulement après l’arrivée de la réponse, il affiche les données.\n🔹 Exemples : Ci-dessous un exemple simple de requête asynchrone pour chacun des modes de gestion(callbacks, promesses, async/await, événements/observables).\n🔹 1. Callbacks C’est le style historique : on passe une fonction de rappel qui sera exécutée quand la réponse arrive.\nfunction getDataCallback(url, callback) { fetch(url) .then(res =\u003e res.json()) .then(data =\u003e callback(null, data)) // succès .catch(err =\u003e callback(err, null)); // erreur } console.log(\"Début\"); getDataCallback(\"https://jsonplaceholder.typicode.com/posts/1\", (err, data) =\u003e { if (err) { console.error(\"Erreur :\", err); } else { console.log(\"Réponse (callback) :\", data); } }); console.log(\"Fin (le callback arrivera plus tard)\");\r🔹 2. Promises Une promesse représente une valeur qui sera disponible plus tard. On utilise .then() et .catch().\nconsole.log(\"Début\"); fetch(\"https://jsonplaceholder.typicode.com/posts/1\") .then(res =\u003e res.json()) .then(data =\u003e console.log(\"Réponse (promise) :\", data)) .catch(err =\u003e console.error(\"Erreur :\", err)); console.log(\"Fin\");\r🔹 3. async/await Syntaxe moderne qui rend le code asynchrone plus lisible, comme du code synchrone.\nasync function getData() { try { console.log(\"Début\"); const res = await fetch(\"https://jsonplaceholder.typicode.com/posts/1\"); const data = await res.json(); console.log(\"Réponse (async/await) :\", data); console.log(\"Fin\"); } catch (err) { console.error(\"Erreur :\", err); } } getData();\r🔹 4. Événements / Observables Dans ce mode, la donnée arrive sous forme de flux continu (par exemple WebSocket, ou un Observable RxJS). Chaque réponse est émise comme un événement, et on y réagit avec un listener.\nExemple avec EventEmitter en Node.js : const EventEmitter = require('events'); const emitter = new EventEmitter(); // Abonnement à l'événement \"data\" emitter.on('data', (msg) =\u003e { console.log(\"Donnée reçue (event) :\", msg); }); // Simulation d’arrivée asynchrone console.log(\"Début\"); setTimeout(() =\u003e emitter.emit('data', { id: 1, text: \"Bonjour 👋\" }), 1000); console.log(\"Fin (les données arrivent en événement)\");\rExemple RxJS (Observables) : import { fromFetch } from \"rxjs/fetch\"; import { switchMap } from \"rxjs\"; console.log(\"Début\"); fromFetch(\"https://jsonplaceholder.typicode.com/posts/1\") .pipe(switchMap(res =\u003e res.json())) .subscribe({ next: data =\u003e console.log(\"Réponse (observable) :\", data), error: err =\u003e console.error(\"Erreur :\", err), complete: () =\u003e console.log(\"Flux terminé\"), }); console.log(\"Fin\");\rNotion d’asynchronisme avec Node.js En Node.js, la majorité des opérations liées aux échanges de données (fichiers, réseau, API, base de données) sont asynchrones.\nCela signifie que le programme ne bloque pas pendant l’attente d’une réponse : il continue à exécuter d’autres instructions et reprend le traitement lorsque le résultat est disponible.\nCe comportement repose sur la boucle d’événements (event loop).\nPour résumé : Les requêtes asynchrones permettent de séparer l’envoi et la réception d’une requête, optimisant ainsi la performance, la réactivité et la capacité à traiter plusieurs opérations en parallèle.\nRésumé des modes de gestion des rquêtes asynchrones :\nCallback : fonction déclenchée quand la réponse arrive. Promise : objet représentant un résultat futur (succès ou erreur). async/await : syntaxe simplifiée basée sur les promesses. Événements/Observables : idéal pour flux continus de données. Autres ressources : MDN : Introduction au JavaScript asynchrone",
    "description": "🔹 Définition Une requête asynchrone est une requête qui ne bloque pas l’exécution du programme pendant l’attente de la réponse. Le programme peut continuer à effectuer d’autres tâches, et traite la réponse uniquement lorsqu’elle est disponible (via un mécanisme de notification, callback, promesse, ou événement).\n🔹 Pourquoi asynchrone ? Performance : éviter qu’une application soit bloquée par une opération lente (accès réseau, lecture disque). Scalabilité : permettre à un serveur de gérer plusieurs connexions simultanées. Expérience utilisateur : garder les interfaces réactives (ex. : chargement d’un contenu sans recharger toute la page). 🔹 Cas d’utilisation Web : AJAX (Asynchronous JavaScript and XML) pour charger des données sans recharger la page. Applications mobiles : appel à une API distante tout en maintenant l’interface fluide. Systèmes distribués : communication entre microservices. Base de données : requêtes envoyées en tâche de fond. 🔹 Comparaison avec les requêtes synchrones Synchrone : le programme attend la fin de la requête avant de continuer → simple, mais bloquant. Asynchrone : le programme envoie la requête, continue d’exécuter d’autres instructions, puis gère la réponse quand elle arrive. 🔹 Modes de gestion Callbacks : fonction appelée quand la réponse arrive. Promesses : objet représentant une valeur future (résolue ou rejetée). async/await : syntaxe moderne pour écrire du code asynchrone de manière lisible. Événements/observables : modèle réactif, utile pour gérer des flux continus de données. 🔹 Exemple générique (pseudo-code) print(\"Début du programme\")\renvoyer requête asynchrone à l’API:\rquand la réponse est reçue:\rafficher(\"Réponse :\", données)\rprint(\"Fin du programme (la réponse arrivera plus tard)\")\r👉 Résultat : le programme affiche “Début” et “Fin” immédiatement, puis seulement après l’arrivée de la réponse, il affiche les données.",
    "tags": [],
    "title": "🌐 Requêtes asynchrones",
    "uri": "/420-514/httprequestdataformat/asyncrequest/index.html"
  },
  {
    "breadcrumb": "Collecte et interprétation de données \u003e Requêtes HTTP et format de données",
    "content": "JSON et XML La manipulation de données JSON et XML est essentielle dans le développement d’applications web modernes, car ces formats sont couramment utilisés pour l’échange de données entre les serveurs et les clients. Voici un guide sur la façon de manipuler ces données en utilisant JavaScript.\n1. Manipulation de données JSON JSON (JavaScript Object Notation) est un format de données léger, facile à lire et à écrire pour les humains, et facile à analyser et à générer pour les machines.\nParser des données JSON Pour convertir une chaîne JSON en un objet JavaScript, vous pouvez utiliser JSON.parse.\nExemple :\nconst jsonString = '{\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}'; const obj = JSON.parse(jsonString); console.log(obj.name); // \"John\" console.log(obj.age); // 30 console.log(obj.city); // \"New York\"\rConvertir un Objet JavaScript en JSON Pour convertir un objet JavaScript en une chaîne JSON, utilisez JSON.stringify.\nExemple :\nconst obj = { name: \"John\", age: 30, city: \"New York\" }; const jsonString = JSON.stringify(obj); console.log(jsonString); // '{\"name\":\"John\",\"age\":30,\"city\":\"New York\"}'\rManipuler des données JSON Vous pouvez facilement accéder, modifier, ajouter ou supprimer des propriétés dans un objet JSON.\nExemple :\nconst obj = { name: \"John\", age: 30, city: \"New York\" }; // Accéder à une propriété console.log(obj.name); // \"John\" // Modifier une propriété obj.age = 31; // Ajouter une nouvelle propriété obj.country = \"USA\"; // Supprimer une propriété delete obj.city; console.log(obj); // { name: \"John\", age: 31, country: \"USA\" }\r2. Manipulation de données XML XML (eXtensible Markup Language) est un format plus verbeux souvent utilisé dans les systèmes plus anciens ou pour des besoins spécifiques. Manipuler XML en JavaScript nécessite un peu plus de code comparé à JSON.\nParser des données XML Pour analyser une chaîne XML en un objet Document, utilisez DOMParser.\nExemple :\nconst xmlString = ` \u003cperson\u003e \u003cname\u003eJohn\u003c/name\u003e \u003cage\u003e30\u003c/age\u003e \u003ccity\u003eNew York\u003c/city\u003e \u003c/person\u003e `; const parser = new DOMParser(); const xmlDoc = parser.parseFromString(xmlString, \"text/xml\"); console.log(xmlDoc.getElementsByTagName(\"name\")[0].childNodes[0].nodeValue); // \"John\" console.log(xmlDoc.getElementsByTagName(\"age\")[0].childNodes[0].nodeValue); // \"30\"\rConvertir un objet Document en chaîne XML Pour convertir un objet Document en une chaîne XML, utilisez XMLSerializer.\nExemple :\nconst serializer = new XMLSerializer(); const xmlString = serializer.serializeToString(xmlDoc); console.log(xmlString);\rManipuler des données XML Vous pouvez accéder et modifier les nœuds XML de manière similaire à la manipulation du DOM HTML.\nExemple :\n// Accéder à un élément const nameElement = xmlDoc.getElementsByTagName(\"name\")[0]; console.log(nameElement.textContent); // \"John\" // Modifier un élément nameElement.textContent = \"Jane\"; // Ajouter un nouvel élément const countryElement = xmlDoc.createElement(\"country\"); countryElement.textContent = \"USA\"; xmlDoc.getElementsByTagName(\"person\")[0].appendChild(countryElement); // Supprimer un élément const cityElement = xmlDoc.getElementsByTagName(\"city\")[0]; cityElement.parentNode.removeChild(cityElement); console.log(new XMLSerializer().serializeToString(xmlDoc)); // \u003cperson\u003e\u003cname\u003eJane\u003c/name\u003e\u003cage\u003e30\u003c/age\u003e\u003ccountry\u003eUSA\u003c/country\u003e\u003c/person\u003e\rÀ retenir : JSON : Plus simple et natif pour JavaScript, facile à manipuler avec JSON.parse et JSON.stringify. XML : Nécessite plus de travail, avec des outils comme DOMParser et XMLSerializer pour l’analyse et la sérialisation. Conversion entre JSON et XML : Non native, nécessite des fonctions personnalisées. Pour un affichage bien présentable des fichier JSON sur le navigateur Chrome, vous pouvez installer l’extension suivante :\nJSON Beautifier \u0026 Editor - Chrome Web Store",
    "description": "JSON et XML La manipulation de données JSON et XML est essentielle dans le développement d’applications web modernes, car ces formats sont couramment utilisés pour l’échange de données entre les serveurs et les clients. Voici un guide sur la façon de manipuler ces données en utilisant JavaScript.\n1. Manipulation de données JSON JSON (JavaScript Object Notation) est un format de données léger, facile à lire et à écrire pour les humains, et facile à analyser et à générer pour les machines.",
    "tags": [],
    "title": "📘 Manipulation de données",
    "uri": "/420-514/httprequestdataformat/dataformat/index.html"
  },
  {
    "breadcrumb": "Collecte et interprétation de données \u003e Ressources utiles",
    "content": "Introduction à Git Git est un logiciel de contrôle de version. Il permet de gérer des fichiers et leur évolution dans le temps.\nIl permet de retracer l’origine de chaque modification, de rétablir des versions précédentes et permet l’intégration de modifications effectuées en parallèle.\nConcept Le principe d’un gestionnaire de version est qu’il gère un document comme “une base” à laquelle est ajouté une suite de modifications.\nIl y a un dépôt commun (Remote) et les contributeurs travaillent sur des versions locales.\nLorsqu’un contributeur a réalisé une modification qui est prête à l’envoyer, il pousse (push) celle-ci vers le dépôt. Le dépôt garde la trace avec un identifiant unique.\nGit est en fait un gestionnaire de version décentralisé. Il y a 2 dépôts : remote et local. De plus, il maintient une version brouillon (staged, sandbox) sur le poste local.\nGit clone Lorsque vous devez récupérer le code de votre repository (dépôt remote):\ngit clone https://github.com/420-411-MV/demo-i18n.git\nSi vous avez configuré la clef SSH dans github par exemple:\ngit clone git@github.com:cegepmv/420-411.git\nGit Commit Le principe de la commande commit est de déposer les modifications sur une dépôt local. Il faut également être vigilant au niveau de la branche utilisé pour le commit. De plus, il est important de mettre souvent à jour la branche avant de procéder à un commit.\nLorsqu’on fait la commande commit, on doit y ajouter un message. En entreprise, on joint souvent un identifiant pour référer à la tâche en cours. Après cet identifiant, on peut y mettre une description. Par exemple:\n“PRJ-3428: Ajout de tests unitaires sur la méthode du service getClients”\nLorsqu’on relie l’identifiant et les commits, on peut alors connaître le travail effectué dans le code pour une tâche donnée dans le système de gestion des projets (Jira, Clickup, Zoho, Zenhub, Asana, Monday.com, etc.).\ngit commit -m \"Votre message\"\rGit Push La commande git push permet de pousser (la branche actuelle de) le local vers le remote : git applique alors successivement tous les commit au remote.\nIl est fortement recommandé de faire un git fetch / pull avant de procéder à celui-ci. À moins d’être seul dans ce repository et/ou la branche visée.\nGit Fetch, checkout, pull La commande git fetch permet de mettre à jour notre dépôt local en récupérant l’ état courant qui remote. La commande git checkout permet de les appliquer à la copie de travail (et donc de les voir).\nLa commande git pull fait les deux à la fois.\nPensez à vous mettre à jour avant chaque session de travail !\nC’est la première chose qu’un développeur fait chaque matin en se mettant au travail, dans beaucoup de cas.\nGit status La commande git status vous permet de connaître l’état courant de vos copies locales (les modifications ont-elles été commitées, les fichiers ajoutés, les commit pushé).\nLes interface graphiques (dont intelliJ) vous l’indique souvent par des couleurs et icones.\nGit logs La commande vous permet de voir tous les commits et tous les identifiants (Commit ID) pour chaque commit effectué. Ces commit peuvent être fort utili pour faire d’autres commandes tel que git revert, git cherry-pick pour ne nommer que celles-ci.\nGit merge Cette commande permet d’appliquer les changements (fusionner) d’une autre branche à votre branche sélectionnée dans votre repository locale. Il y a souvent des conflits lors d’une fusion. Surtout si vous avez travailler dans un même fichier qu’un ou une de vos collègues.\nVous devez tenter de résoudre les conflits avec des outils en ligne de commande ou à l’aide d’un interface graphique. C’est une habilité à acquérir avec le temps. C’est parfois très complexe et si l’opération n’est pas effectée avec soin, il peut y avoir injection de bug.\n// on va sur la branche master\rgit checkout master\r// on merge hotfix dans master\rgit merge hotfix\rGit Rebase Le rebase consiste à changer la base de votre branche d’un commit vers un autre, donnant l’illusion que vous avez créé votre branche à partir d’un commit différent.\ngit rebase \u003cbase\u003e\rGit stash Lorsque vous voulez sauvegarder l’état actuel de votre répertoire de travail. C’est possible de le faire avec git stash et de revenir à un répertoire de travail propre sans ces modifications. Vous pourrez ensuite récupérer ce travail en utilisant le nom que vous lui aurez donné. Vous pouvez en avoir plusieurs sauvegardés dans une liste.\n// Sauvegarder les changements courrants.\rgit stash\r// Récupérer les changements précédents.\rgit stash pop\r// Voir la liste des stash\rgit stash list\rMeilleures pratiques Ne pas laisser les branches inactives. Effacer votre branche de bugfix ou de fonctionnalité si vous avez terminé.\nNe pas prendre les branches pour plusieurs fonctionnalités. Séparez vos tâches en plus petites et faites des commits plus souvent.\nRécupérer la branche parent le plus souvent possible. Soit en faisant un merge ou en faisant des rebases.\nCommuniquez avec votre équipe vos intentions! Ne travaillez pas sur les mêmes modules si possible.\nDans chaque Pull Request. Vous devriez ajouter des tests unitaires si vous avez travaillé sur une fonctionnalité ou un fix.\nAvant le jour de la mise en production. Vous devriez créer une branche à partir du main ou master. Donnez-lui le nom de MEP_4OCT_24 par exemple. Effectuez le merge de la branche RELEASE visée vers la branche de la copie de la production MEP_4OCT_24. Assurez-vous de bien merger tous les éléments. Testez que votre branche fonctionne et qu’elle est bien compilée. Le jour J de la mise en production. Mergez cette branche vers la production. Les conflits auront déjà été résolus! Bingo.\nGitflow Pour maintenir une certain cohésion en entreprise, un modèle de branche a été proposé. Il implique de séparer les branches de développement et les branches primaires qui sont déployés dans multiples environnements.\nSource:\nhttps://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow\nRéférence Richard E. Silverman (2013), Git Pocket Guide, O’Reilly\nAlice Jacquot, Introduction à Git https://www.lri.fr/~jacquot/ipo/introAGit.pdf",
    "description": "Introduction à Git Git est un logiciel de contrôle de version. Il permet de gérer des fichiers et leur évolution dans le temps.\nIl permet de retracer l’origine de chaque modification, de rétablir des versions précédentes et permet l’intégration de modifications effectuées en parallèle.\nConcept Le principe d’un gestionnaire de version est qu’il gère un document comme “une base” à laquelle est ajouté une suite de modifications.\nIl y a un dépôt commun (Remote) et les contributeurs travaillent sur des versions locales.",
    "tags": [],
    "title": "Gestionnaire de source",
    "uri": "/420-514/ressourcesutiles/gestioncodesource/index.html"
  },
  {
    "breadcrumb": "Collecte et interprétation de données \u003e Préalables",
    "content": "Cadriciel côté serveur Qu’est-ce qu’un cadriciel côté serveur ? Un cadriciel (ou framework) est un ensemble structuré d’outils, de bibliothèques et de conventions qui facilite et accélère le développement d’applications. Lorsqu’on parle de cadriciel côté serveur, on fait référence aux frameworks conçus pour la partie backend d’une application, c’est-à-dire :\nla logique métier (traitement des données, règles d’affaires) la gestion des requêtes/réponses entre le client et le serveur la communication avec les bases de données la sécurité et la gestion des utilisateurs En d’autres termes, au lieu de tout programmer « à la main », on s’appuie sur une infrastructure déjà prête qui propose des solutions éprouvées et standardisées.\nPourquoi utiliser un cadriciel côté serveur ? Gain de temps et productivité : on évite de réinventer la roue pour gérer les routes, la sécurité, ou encore les sessions. Organisation du code : un framework impose une structure claire (souvent basée sur le modèle MVC ou MVVM). Sécurité intégrée : gestion des failles courantes (injections SQL, XSS, CSRF, etc.). Évolutivité : plus simple d’ajouter de nouvelles fonctionnalités. Communauté et support : documentation, forums, mises à jour régulières. Exemples de cadriciels côté serveur Node.js / Express.js (JavaScript / TypeScript) Django et Flask (Python) Spring Boot (Java) ASP.NET Core (C#) Laravel et Symfony (PHP)",
    "description": "Cadriciel côté serveur Qu’est-ce qu’un cadriciel côté serveur ? Un cadriciel (ou framework) est un ensemble structuré d’outils, de bibliothèques et de conventions qui facilite et accélère le développement d’applications. Lorsqu’on parle de cadriciel côté serveur, on fait référence aux frameworks conçus pour la partie backend d’une application, c’est-à-dire :\nla logique métier (traitement des données, règles d’affaires) la gestion des requêtes/réponses entre le client et le serveur la communication avec les bases de données la sécurité et la gestion des utilisateurs En d’autres termes, au lieu de tout programmer « à la main », on s’appuie sur une infrastructure déjà prête qui propose des solutions éprouvées et standardisées.",
    "tags": [],
    "title": "📘 Cadriciels rappel",
    "uri": "/420-514/intro/frameworkbe/index.html"
  },
  {
    "breadcrumb": "",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Collecte et interprétation de données",
    "uri": "/420-514/index.html"
  },
  {
    "breadcrumb": "Collecte et interprétation de données",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/420-514/categories/index.html"
  },
  {
    "breadcrumb": "Collecte et interprétation de données",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/420-514/tags/index.html"
  }
]
