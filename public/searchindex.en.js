var relearn_searchindex = [
  {
    "breadcrumb": "Collecte et interprÃ©tation de donnÃ©es",
    "content": "Dans ce module nous ferons une courte rÃ©vision des notions essentielles au cours.",
    "description": "Dans ce module nous ferons une courte rÃ©vision des notions essentielles au cours.",
    "tags": [],
    "title": "PrÃ©alables",
    "uri": "/420-514/intro/index.html"
  },
  {
    "breadcrumb": "Collecte et interprÃ©tation de donnÃ©es",
    "content": "Dans ce module, on va dÃ©velopper une API ou une application serveur complÃ¨te avec un cadriciel moderne.",
    "description": "Dans ce module, on va dÃ©velopper une API ou une application serveur complÃ¨te avec un cadriciel moderne.",
    "tags": [],
    "title": "Cadriciel (framework) cÃ´tÃ© serveur : Node.js / express",
    "uri": "/420-514/nodejsframeworkexpress/index.html"
  },
  {
    "breadcrumb": "Collecte et interprÃ©tation de donnÃ©es",
    "content": "Dans ce chapitre, nous allons dÃ©couvrir le fonctionnement des requÃªtes HTTP et leur rÃ´le dans lâ€™Ã©change de donnÃ©es sur le Web. Nous verrons comment un client, tel quâ€™un navigateur, envoie une requÃªte au serveur pour accÃ©der Ã  une ressource, et comment le serveur rÃ©pond avec un code de statut, des en-tÃªtes et Ã©ventuellement un contenu. Nous prÃ©senterons les diffÃ©rentes mÃ©thodes HTTP (GET, POST, etc.), la structure dâ€™une requÃªte et dâ€™une rÃ©ponse, ainsi que des exemples concrets dâ€™Ã©changes entre client et serveur.",
    "description": "Dans ce chapitre, nous allons dÃ©couvrir le fonctionnement des requÃªtes HTTP et leur rÃ´le dans lâ€™Ã©change de donnÃ©es sur le Web. Nous verrons comment un client, tel quâ€™un navigateur, envoie une requÃªte au serveur pour accÃ©der Ã  une ressource, et comment le serveur rÃ©pond avec un code de statut, des en-tÃªtes et Ã©ventuellement un contenu. Nous prÃ©senterons les diffÃ©rentes mÃ©thodes HTTP (GET, POST, etc.), la structure dâ€™une requÃªte et dâ€™une rÃ©ponse, ainsi que des exemples concrets dâ€™Ã©changes entre client et serveur.",
    "tags": [],
    "title": "RequÃªtes HTTP et format de donnÃ©es",
    "uri": "/420-514/httprequestdataformat/index.html"
  },
  {
    "breadcrumb": "Collecte et interprÃ©tation de donnÃ©esÂ \u003eÂ PrÃ©alables",
    "content": "Rappel API REST ğŸŒ¼ Une API REST se doit dâ€™Ãªtre sans Ã©tat Stateless. La communication entre le client et le serveur ne doit pas dÃ©pendre dâ€™un quelconque contexte provenant du serveur. ğŸŒ¼ Ainsi, chaque requÃªte doit contenir lâ€™ensemble des informations nÃ©cessaires Ã  son traitement. Cela permet au de traiter indiffÃ©remment les requÃªtes de plusieurs clients via de multiples instances de serveurs.\nğŸŒ¼ Pour chaque rÃ©ponse renvoyÃ©e par lâ€™API, un code doit Ãªtre envoyÃ©, ce code correspond Ã  lâ€™Ã©tat de la requÃªte et dÃ©pend de la rÃ©ussite ou non de celle-ci.\nLes codes de statuts les plus courants que lâ€™on retrouve gÃ©nÃ©ralement sur le Web sont :\nCode DÃ©finition 200 OK Tout sâ€™est bien passÃ© 201 Created La crÃ©ation de la ressource sâ€™est bien passÃ©e (il nâ€™est pas rare que les attributs de la nouvelle ressource soient aussi renvoyÃ©s dans la rÃ©ponse. Dans ce cas, lâ€™URL de cette ressource nouvellement crÃ©Ã©e est ajoutÃ©e via un Header Location) 204 NO Content MÃªme principe que pour la 201, mais cette fois-ci, le contenu de la ressource nouvellement crÃ©Ã©e ou modifiÃ©e nâ€™est pas renvoyÃ© en rÃ©ponse 304 Not modified Le contenu nâ€™a pas Ã©tÃ© modifiÃ© depuis la derniÃ¨re fois quâ€™elle a Ã©tÃ© mise en cache 400 Bad request La demande nâ€™a pas pu Ãªtre traitÃ©e correctement 401 Unauthorized Lâ€™authentification a Ã©chouÃ© 403 Forbidden Lâ€™accÃ¨s Ã  cette ressource nâ€™est pas autorisÃ© 404 Not found La ressource nâ€™existe pas 500 Server error Le serveur a rencontrÃ© un problÃ¨me Verbes HTTP (GET, POST, PUT, DELETE) GET\nExemple: Vous souhaitez afficher une liste dâ€™articles sur un blog.\nRequÃªte GET: GET /articles HTTP/1.1\nAction: Le serveur retourne une liste dâ€™articles au format JSON.\nRÃ©ponse:\n[ { \"id\": 1, \"title\": \"Article 1\", \"content\": \"Contenu de l'article 1\" }, { \"id\": 2, \"title\": \"Article 2\", \"content\": \"Contenu de l'article 2\" } ]\rPOST\nExemple: Un utilisateur soumet un formulaire pour crÃ©er un nouvel article.\nRequÃªte POST: POST /articles HTTP/1.1\nCorps de la requÃªte:\n{ \"title\": \"Nouvel Article\", \"content\": \"Contenu du nouvel article\" }\rAction: Le serveur crÃ©e un nouvel article avec les donnÃ©es fournies. RÃ©ponse: 201 Created avec lâ€™article crÃ©Ã© en retour. PUT\nExemple: Un utilisateur souhaite mettre Ã  jour un article existant.\nRequÃªte PUT: PUT /articles/1 HTTP/1.1\nCorps de la requÃªte:\n{ \"title\": \"Article mis Ã  jour\", \"content\": \"Contenu mis Ã  jour\" }\rAction: Le serveur met Ã  jour lâ€™article avec les nouvelles donnÃ©es\nRÃ©ponse: 200 OK avec lâ€™article mis Ã  jour en retour.\nDELETE\nExemple: Un utilisateur souhaite supprimer un article. RequÃªte DELETE: DELETE /articles/1 HTTP/1.1 Action: Le serveur supprime lâ€™article avec lâ€™ID 1. RÃ©ponse: 204 No Content (pas de contenu retournÃ©, car la ressource a Ã©tÃ© supprimÃ©e).",
    "description": "Rappel API REST ğŸŒ¼ Une API REST se doit dâ€™Ãªtre sans Ã©tat Stateless. La communication entre le client et le serveur ne doit pas dÃ©pendre dâ€™un quelconque contexte provenant du serveur. ğŸŒ¼ Ainsi, chaque requÃªte doit contenir lâ€™ensemble des informations nÃ©cessaires Ã  son traitement. Cela permet au de traiter indiffÃ©remment les requÃªtes de plusieurs clients via de multiples instances de serveurs.\nğŸŒ¼ Pour chaque rÃ©ponse renvoyÃ©e par lâ€™API, un code doit Ãªtre envoyÃ©, ce code correspond Ã  lâ€™Ã©tat de la requÃªte et dÃ©pend de la rÃ©ussite ou non de celle-ci.",
    "tags": [],
    "title": "ğŸ“˜ RÃ©vision",
    "uri": "/420-514/intro/revision/index.html"
  },
  {
    "breadcrumb": "Collecte et interprÃ©tation de donnÃ©esÂ \u003eÂ Cadriciel (framework) cÃ´tÃ© serveur : Node.js / express",
    "content": "Introduction Ã  Node.js Historique Avant 2009 le langage (JavaScript) nâ€™Ã©tait utilisÃ© quâ€™au cÃ´tÃ© client et ne peut Ãªtre exÃ©cutÃ© que dans le navigateur (browser) Le code JavaScript Ã©tait donc cantonnÃ© au cÃ´tÃ© client. Il servait Ã  :\nmanipuler le DOM (Document Object Model), valider des formulaires, crÃ©er des animations simples, ajouter de lâ€™interactivitÃ© Ã  la page. âš ï¸ Aucune possibilitÃ© de gÃ©rer :\ndes fichiers sur le serveur, une base de donnÃ©es, un systÃ¨me de fichiers ou un rÃ©seau. Tout cela Ã©tait rÃ©servÃ© aux langages cÃ´tÃ© serveur (PHP, Java, Python, C#, etc.).\nEn 2009, Ryan Dahl introduit Node.js, une innovation qui a changÃ© lâ€™histoire de JavaScript. Node.js reprend le moteur V8 de Google Chrome (rapide et optimisÃ© en C++).\nIl lâ€™embarque en dehors du navigateur, crÃ©ant un nouvel environnement dâ€™exÃ©cution JavaScript cÃ´tÃ© serveur. Avec Node.js, JavaScript peut enfin :\nlire et Ã©crire dans des fichiers, gÃ©rer des connexions rÃ©seau, dialoguer avec des bases de donnÃ©es, exÃ©cuter des applications serveur complÃ¨tes. ğŸ‘‰ Environnement dâ€™exÃ©cution = Node.js (hors navigateur)\nğŸ‘‰ Moteur = V8, mais intÃ©grÃ© dans un cadre Ã©largi avec des API systÃ¨me.\nAttention : moteur \u003c\u003e environnement\rMoteur JavaScript : logiciel qui traduit le code JavaScript en instructions machine. (Ex. : V8, SpiderMonkey). Environnement dâ€™exÃ©cution : contexte dans lequel sâ€™exÃ©cute le code, incluant le moteur + les API disponibles. Dans le navigateur : API DOM, Ã©vÃ©nements, cookiesâ€¦ Dans Node.js : API fichiers, rÃ©seau, processus, modules systÃ¨meâ€¦ Queâ€™est-ce que câ€™est Node.js ? Node.js est un environnement dâ€™exÃ©cution open-source pour crÃ©er des applications et outils cÃ´tÃ© serveur en JavaScript (tel que les APIs), utilisÃ© hors navigateur (directement sur lâ€™ordinateur ou le serveur). Node se distingue par dâ€™excellentes performances, un code uniquement en JavaScript, et un vaste Ã©cosystÃ¨me via NPM, ce qui simplifie le dÃ©veloppement dâ€™applications web performantes.\nSource : https://app.pluralsight.com/library/courses/nodejs-express-foundations/description\nAvantages de Node.js Performance : OptimisÃ© pour les applications web Ã©volutives, notamment en temps rÃ©el. Un langage unique : JavaScript est utilisÃ© Ã  la fois cÃ´tÃ© client et serveur. Ã‰cosystÃ¨me NPM : AccÃ¨s Ã  de nombreuses bibliothÃ¨ques rÃ©utilisables. Installer Node js Pour installer Node Js aller sur le lien suivant : https://nodejs.org/fr/download/package-manager\nExemples de code Hello Node.js : Un exemple simple de serveur web Node.js qui rÃ©pond â€œSalut tout le mondeâ€.\nfunction sayHello(name) { console.log(`Hello ${name}!`); } sayHello('students');\rLe systÃ¨me node module ğŸŒ Les objets globaux : Navigateur vs Node.js Dans le navigateur Lâ€™environnement dâ€™exÃ©cution est le navigateur. Lâ€™objet global est : window. Tous les objets, fonctions ou variables globales sont attachÃ©s Ã  window. Exemple :\nconsole.log(window.document); // AccÃ¨de au DOM window.alert(\"Bonjour depuis le navigateur !\");\rDans Node.js Lâ€™environnement dâ€™exÃ©cution est Node.js (hors navigateur). Lâ€™objet global est : global. Tous les objets et fonctions globales comme : console.log() setTimeout() clearTimeout() setInterval() clearInterval() etc. sont attachÃ©s Ã  global.\nExemple :\nglobal.console.log(\"Salut depuis Node.js ğŸ‘‹\"); setTimeout(() =\u003e { global.console.log(\"Ceci sâ€™exÃ©cute aprÃ¨s 1 seconde\"); }, 1000);\râš ï¸ Dans Node.js, il nâ€™y a pas de window ni de document â†’ pas de DOM.\nNode.js fournit aussi un alias globalThis, qui est un standard JavaScript moderne : js\rglobalThis.console.log(\"Salut avec globalThis\");\rğŸ‘‰ Ainsi, on a :\nNavigateur : window === globalThis âœ… Node.js : global === globalThis âœ… en rÃ©sumÃ©\nContexte Objet global Exemple Navigateur window window.alert(\"Bonjour\") Node.js global global.console.log(\"Salut\") Standard (les deux) globalThis globalThis.setTimeout(...) ğŸ“¦ Les modules en Node.js En node chaque fichier est un module et les fonctions ainsi que les variables dÃ©finies dans ce fichier ne sont disponible quâ€™Ã  lâ€™interieur de ce module. Cela permet :\ndâ€™organiser le code en plusieurs fichiers, dâ€™Ã©viter la duplication, de partager des fonctionnalitÃ©s entre projets. Types de modules dans Node.js Modules internes (built-in)\nDÃ©jÃ  fournis avec Node.js.\nExemples :\nfs (fichiers), http (serveur web), path (chemins de fichiers), os (systÃ¨me dâ€™exploitation). const fs = require('fs'); fs.writeFileSync('test.txt', 'Bonjour Node.js !');\rModules locaux (crÃ©Ã©s par nous)\nNos propres fichiers .js. Exemple : // fichier math.js function addition(a, b) { return a + b; } module.exports = addition;\r// fichier app.js const addition = require('./math'); console.log(addition(2, 3)); // 5 Modules tiers (installÃ©s avec npm)\nModules crÃ©Ã©s par la communautÃ©. Exemple : express, lodash, mongoose. npm install express\rconst express = require('express'); const app = express(); app.get('/', (req, res) =\u003e res.send('Hello Express ğŸš€')); app.listen(3000);\rğŸ“¦SystÃ¨mes de modules a) CommonJS (historiquement utilisÃ© par Node.js) Utilise require() pour importer. Utilise module.exports pour exporter. // math.js module.exports = { addition: (a, b) =\u003e a + b, multiplication: (a, b) =\u003e a * b };\r// app.js const math = require('./math'); console.log(math.addition(2, 3));\rb) ES Modules (standard moderne JavaScript) Utilise import / export. NÃ©cessite dâ€™ajouter \"type\": \"module\" dans package.json. // math.mjs export function addition(a, b) { return a + b; }\r// app.mjs import { addition } from './math.mjs'; console.log(addition(4, 5));\rVoici un rÃ©sumÃ© comparatif\nType de module Exemple import Exemple export CommonJS (par dÃ©faut Node.js) const x = require('./fichier') module.exports = ... ES Module (standard moderne) import x from './fichier.js' export default ... ou export function ... Utilisation des Modules Les modules permettent dâ€™organiser et rÃ©utiliser le code. Vous pouvez crÃ©er et importer des modules en utilisant require().\nExemple de module :\nexports.area = function (width) { return width * width; }; exports.perimeter = function (width) { return 4 * width; };\rOu\n// dans mathOperations.js function add(a, b) { return a + b; } function subtract(a, b) { return a - b; } function multiply(a, b) { return a * b; } function divide(a, b) { if (b === 0) { throw new Error('Division par zÃ©ro'); } return a / b; } // Export des fonctions pour les rendre disponibles dans d'autres fichiers module.exports = { add, subtract, multiply, divide };\rExemple dâ€™un simple serveur\nconst http = require(\"http\"); const hostname = \"127.0.0.1\"; const port = 8000; const server = http.createServer((req, res) =\u003e { res.writeHead(200, { \"Content-Type\": \"text/plain\" }); res.end(\"Salut tout le monde\"); }); server.listen(port, hostname, () =\u003e { console.log(`Le serveur tourne Ã  l'adresse http:\\\\${hostname}:${port}/`); });\rGestion des paquets avec npm Initialiser un projet : npm init -y Installer un module : npm install express Sauvegarder en dÃ©pendances dans package.json. Scripts personnalisÃ©s :\n\"scripts\": { \"start\": \"node app.js\", \"dev\": \"nodemon app.js\" }\rLire et Ã©crire dans des fichiers Node.js fournit le module fs (File System) :\n// files.js const fs = require('fs'); // Ã‰criture fs.writeFileSync('message.txt', 'Bonjour Node.js !'); // Lecture const data = fs.readFileSync('message.txt', 'utf8'); console.log(\"Contenu du fichier :\", data);\rAsynchronisme en Node.js Node.js excelle dans les opÃ©rations asynchrones (lecture de fichiers, accÃ¨s rÃ©seau).\n// async.js const fs = require('fs'); fs.readFile('message.txt', 'utf8', (err, data) =\u003e { if (err) { console.error('Error reading the file:', err); return; } console.log(\"Lecture asynchrone :\", data); }); console.log(\"Cette ligne sâ€™affiche avant la lecture du fichier !\");\rğŸ‘‰ RÃ©sultat : la lecture se fait en arriÃ¨re-plan, pendant que le reste du code continue Ã  sâ€™exÃ©cuter.\nGestion des Ã©vÃ©nements (EventEmitter) Node.js est basÃ© sur un modÃ¨le Ã©vÃ©nementiel.\nconst EventEmitter = require('events'); const emitter = new EventEmitter(); emitter.on('salut', (nom) =\u003e { console.log(`Bonjour ${nom} !`); }); emitter.emit('salut', 'Alice');\rğŸ‘‰ Utile pour crÃ©er des systÃ¨mes rÃ©actifs (logs, notifications, etc.).\nLiens utiles : Site de Node.js :\nNode.js â€” ExÃ©cuter du JavaScript partout\nDocumentation officielle de Node.js\nFormation : https://app.pluralsight.com/library/courses/nodejs-express-foundations",
    "description": "Introduction Ã  Node.js Historique Avant 2009 le langage (JavaScript) nâ€™Ã©tait utilisÃ© quâ€™au cÃ´tÃ© client et ne peut Ãªtre exÃ©cutÃ© que dans le navigateur (browser) Le code JavaScript Ã©tait donc cantonnÃ© au cÃ´tÃ© client. Il servait Ã  :\nmanipuler le DOM (Document Object Model), valider des formulaires, crÃ©er des animations simples, ajouter de lâ€™interactivitÃ© Ã  la page. âš ï¸ Aucune possibilitÃ© de gÃ©rer :\ndes fichiers sur le serveur, une base de donnÃ©es, un systÃ¨me de fichiers ou un rÃ©seau. Tout cela Ã©tait rÃ©servÃ© aux langages cÃ´tÃ© serveur (PHP, Java, Python, C#, etc.).",
    "tags": [],
    "title": "ğŸ“˜ NodeJs",
    "uri": "/420-514/nodejsframeworkexpress/nodejs/index.html"
  },
  {
    "breadcrumb": "Collecte et interprÃ©tation de donnÃ©esÂ \u003eÂ Cadriciel (framework) cÃ´tÃ© serveur : Node.js / express",
    "content": "Introduction Ã  Express Express est un framework web minimaliste pour Node.js, permettant de crÃ©er des applications web robustes et modulaires. Il facilite la gestion des routes, le rendu de vues dynamiques, et lâ€™intÃ©gration de middlewares pour diverses tÃ¢ches comme les sessions ou lâ€™authentification.\nExemple dâ€™Express const express = require(\"express\"); const app = express(); const port = 3000; app.get(\"/\", (req, res) =\u003e { res.send(\"Hello World!\"); }); app.listen(port, () =\u003e { console.log(`Application Ã  l'Ã©coute sur le port ${port}!`); });\rSource : https://app.pluralsight.com/library/courses/nodejs-express-foundations/description\nMiddleware et gestion des erreurs Les middlewares sont des fonctions intermÃ©diaires dans le traitement des requÃªtes. Ils sont essentiels pour gÃ©rer les fichiers statiques, les sessions, les erreurs, etc.\nSource : https://app.pluralsight.com/library/courses/nodejs-express-foundations/description\nconst express = require(\"express\"); const app = express(); let middlewareFunction = (req, res, next) =\u003e { // Logique du middleware next(); }; app.use(middlewareFunction); app.listen(3000);\rUn middleware dans Node.js est une fonction qui a accÃ¨s Ã  lâ€™objet de requÃªte (req), lâ€™objet de rÃ©ponse (res), et Ã  la fonction next() dans le cycle de traitement des requÃªtes HTTP.\nLes middlewares permettent de modifier, dâ€™analyser, dâ€™intercepter ou de rÃ©pondre aux requÃªtes avant quâ€™elles nâ€™atteignent les routes finales. Ils sont trÃ¨s utiles pour ajouter des fonctionnalitÃ©s transversales (comme lâ€™authentification, la gestion des erreurs, le logging, etc.) sans modifier chaque route de lâ€™application.\nFonctionnement dâ€™un middleware : Un middleware est une fonction qui peut faire les choses suivantes :\nExÃ©cuter du code. Modifier lâ€™objet de requÃªte (req) ou de rÃ©ponse (res). Terminer le cycle de la requÃªte/rÃ©ponse (par exemple en renvoyant une rÃ©ponse au client). Appeler la fonction next() pour passer la main au middleware suivant dans la chaÃ®ne. Exemple de middleware simple : Voici un exemple basique dâ€™un middleware dans Express :\napp.use((req, res, next) =\u003e { console.log('Middleware exÃ©cutÃ© pour chaque requÃªte'); next(); // Passe la main au middleware ou Ã  la route suivante });\rDans cet exemple :\nCe middleware sâ€™exÃ©cutera pour toutes les requÃªtes reÃ§ues par lâ€™application. Il affiche un message dans la console et appelle next() pour permettre Ã  Express de continuer avec les middlewares suivants ou les routes dÃ©finies. Types de middlewares dans Express : Middlewares dâ€™application :\nCes middlewares sont associÃ©s Ã  lâ€™instance de lâ€™application (app) et sâ€™exÃ©cutent pour toutes les routes ou pour des routes spÃ©cifiques.\nExemple :\napp.use((req, res, next) =\u003e { console.log('Ceci est un middleware d\\\\'application'); next(); });\rMiddlewares spÃ©cifiques Ã  une route :\nIls sâ€™appliquent Ã  une ou plusieurs routes spÃ©cifiques.\nExemple :\napp.get('/user', (req, res, next) =\u003e { console.log('Middleware pour la route /user'); next(); }, (req, res) =\u003e { res.send('Profil utilisateur'); });\rMiddlewares intÃ©grÃ©s :\nExpress fournit des middlewares intÃ©grÃ©s comme express.json() ou express.urlencoded() pour parser les corps des requÃªtes.\nExemple :\napp.use(express.json());\rMiddlewares tiers :\nVous pouvez installer des middlewares fournis par la communautÃ© pour des tÃ¢ches spÃ©cifiques, comme la gestion des sessions, la sÃ©curitÃ©, etc.\nExemple : morgan pour le logging des requÃªtes HTTP.\nconst morgan = require('morgan'); app.use(morgan('dev'));\rMiddlewares de gestion des erreurs :\nUn middleware de gestion des erreurs prend quatre paramÃ¨tres : (err, req, res, next) et est utilisÃ© pour capturer les erreurs et renvoyer des rÃ©ponses appropriÃ©es.\nExemple :\napp.use((err, req, res, next) =\u003e { console.error(err.stack); res.status(500).send('Quelque chose s\\'est mal passÃ© !'); });\rPourquoi utiliser des middlewares ? ModularitÃ© : Ils permettent dâ€™ajouter des fonctionnalitÃ©s rÃ©utilisables, comme la gestion des sessions, sans toucher Ã  chaque route de lâ€™application. ComposabilitÃ© : Les middlewares peuvent Ãªtre chaÃ®nÃ©s pour crÃ©er un pipeline de traitement des requÃªtes. RÃ©utilisabilitÃ© : Vous pouvez crÃ©er des middlewares personnalisÃ©s qui peuvent Ãªtre rÃ©utilisÃ©s Ã  travers plusieurs routes ou applications. Utilisation des bases de donnÃ©es Node.js prend en charge plusieurs bases de donnÃ©es comme MongoDB. Pour connecter votre application Ã  une base de donnÃ©es, vous devez installer le pilote correspondant.\nExemple MongoDB :\nconst MongoClient = require(\"mongodb\").MongoClient; MongoClient.connect(\"mongodb://localhost:27017/animals\", (err, client) =\u003e { if (err) throw err; let db = client.db(\"animals\"); db.collection(\"mammals\").find().toArray((err, result) =\u003e { if (err) throw err; console.log(result); client.close(); }); });\rGestion du logging Autre middlewares pour la gestion du logging, ainsi que pour servir des fichiers statiques comme des pages HTML avec Express.\nAjouter des middlewares pour le logging Les middlewares sont des fonctions qui ont accÃ¨s Ã  lâ€™objet request (req), lâ€™objet response (res) et Ã  la fonction next dans le cycle de requÃªte-rÃ©ponse. Ils sont utiles pour intercepter et gÃ©rer des requÃªtes avant quâ€™elles ne parviennent aux routes dÃ©finies.\nAjouter un middleware de logging Un middleware de logging peut enregistrer chaque requÃªte reÃ§ue par le serveur. Ajoutez le code suivant au dÃ©but de votre fichier index.js :\nconst express = require('express'); const app = express(); const port = 3000; // Middleware de logging app.use((req, res, next) =\u003e { console.log(`${req.method} ${req.url}`); next(); });\rServir des fichiers statiques Pour servir des fichiers statiques comme des pages HTML, CSS, ou des images, Express offre une mÃ©thode simple. CrÃ©ez un dossier public dans votre projet pour stocker ces fichiers.\nCrÃ©er un Dossier public CrÃ©ez le dossier public Ã  la racine de votre projet :\nmkdir public\rAjoutez un fichier HTML dans le dossier public :\nCrÃ©ez un fichier index.html dans le dossier public avec le contenu suivant :\n\u003c!DOCTYPE html\u003e \u003chtml lang=\"fr\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003ePage d'accueil\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eBienvenue sur mon site!\u003c/h1\u003e \u003cp\u003eCeci est une page HTML servie par Express.\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e\rConfigurer Express pour servir les fichiers statiques Ajoutez le code suivant Ã  votre index.js pour permettre Ã  Express de servir les fichiers du dossier public :\n// Servir des fichiers statiques app.use(express.static('public'));\rTester Testez le middleware de logging : Lancez votre serveur avec node index.js et accÃ©dez Ã  diffÃ©rentes routes (par exemple, / ou /info). Vous devriez voir les requÃªtes enregistrÃ©es dans le terminal.\nTestez le middleware de gestion des erreurs : Pour simuler une erreur, vous pouvez crÃ©er une route qui lÃ¨ve une exception :\napp.get('/cause-error', (req, res) =\u003e { throw new Error('Erreur simulÃ©e!'); });\rEn accÃ©dant Ã  cette route (GET \u003chttp://localhost:3000/cause-error\u003e), vous verrez le message dâ€™erreur personnalisÃ©.\nTestez la servitude des fichiers statiques : AccÃ©dez Ã  http://localhost:3000/ dans votre navigateur. Vous devriez voir la page HTML crÃ©Ã©e dans public/index.html.\nLe Fichier index.js Voici le code final du fichier index.js :\nconst express = require('express'); const app = express(); const port = 3000; // Middleware de logging app.use((req, res, next) =\u003e { console.log(`${req.method} ${req.url}`); next(); }); // Servir des fichiers statiques app.use(express.static('public')); // Route de base app.get('/', (req, res) =\u003e { res.send('Bienvenue sur mon serveur Express!'); }); // Route pour afficher un message personnalisÃ© app.get('/hello/:name', (req, res) =\u003e { const name = req.params.name; res.send(`Bonjour, ${name}!`); }); // Route qui renvoie les informations sur le serveur app.get('/info', (req, res) =\u003e { res.json({ version: '1.0.0', description: 'Ceci est un serveur simple utilisant Express.js', }); }); // Route pour simuler une erreur app.get('/cause-error', (req, res) =\u003e { throw new Error('Erreur simulÃ©e!'); }); // Middleware de gestion des erreurs app.use((err, req, res, next) =\u003e { console.error(err.stack); res.status(500).send('Quelque chose s\\'est mal passÃ©!'); }); // DÃ©marrer le serveur app.listen(port, () =\u003e { console.log(`Serveur en Ã©coute sur \u003chttp://localhost\u003e:${port}`); });\rUtiliser la librairie de journalisation Winston Winston est une bibliothÃ¨que de journalisation (logging) populaire pour Node.js. Elle permet aux dÃ©veloppeurs de capturer, formater, et gÃ©rer des logs dans diffÃ©rentes sorties (fichiers, console, bases de donnÃ©es, etc.). Winston est flexible et extensible, ce qui en fait un choix idÃ©al pour les projets nÃ©cessitant une gestion fine des logs, notamment pour le dÃ©bogage, la surveillance et le suivi des Ã©vÃ©nements.\nPrincipales fonctionnalitÃ©s de Winston Multiples Transports : Winston peut envoyer des logs vers diffÃ©rents supports appelÃ©s â€œtransportsâ€ (fichiers, bases de donnÃ©es, systÃ¨mes de journalisation distants, etc.). Niveaux de Log : Il prend en charge diffÃ©rents niveaux de log (ex: error, warn, info, debug) pour filtrer et gÃ©rer les logs en fonction de leur importance. Source : app.pluralsight.com/\nFormats de Log : Winston permet de formater les messages de log en JSON, en texte, ou en tout autre format personnalisÃ©. Configuration Flexible : Il est possible de configurer plusieurs loggers, chacun avec ses propres niveaux de log, formats et transports. Installation de Winston Pour installer Winston dans votre projet Node.js, utilisez la commande suivante :\nnpm install winston\rExemple dâ€™utilisation de Winston Voici un exemple simple dâ€™utilisation de Winston pour configurer un logger qui envoie les logs Ã  la console et Ã  un fichier.\nconst winston = require('winston'); // Configuration du logger const logger = winston.createLogger({ // Le niveau minimum de log est dÃ©fini Ã  info. // Cela signifie que tous les logs de niveau info et plus Ã©levÃ©s (ex: warn, error) seront capturÃ©s. level: 'info', // Niveau minimum de log (info, warn, error, etc.) // Les logs sont formatÃ©s en JSON et incluent un timestamp pour chaque message. format: winston.format.combine( winston.format.timestamp(), winston.format.json() // Format des logs en JSON ), // Le logger est configurÃ© avec deux transports : la console et un fichier app.log transports: [ new winston.transports.Console(), // Log vers la console new winston.transports.File({ filename: 'logs/app.log' }) // Log vers un fichier ] }); // Exemple de logs logger.info('L\\'application a dÃ©marrÃ©'); logger.warn('Attention, ceci est un avertissement'); logger.error('Une erreur est survenue');\rExemple du code complet :\nimport express from 'express' import { join } from 'node:path' import { createLogger, format, transports } from 'winston' const app = express() const logger = createLogger({ level: 'info', format: format.combine( format.timestamp(), format.json() ), transports: [ new transports.Console(), new transports.File({ filename: 'logs/app.log' }) ] }) const logAll = function(request, response, next) { logger.info(`L'application a dÃ©marrÃ© : ${request.url}`) logger.warn('Attention, ceci est un avertissement'); logger.error('Une erreur est survenue'); next() } app.use(express.json()) app.use(express.static(join(process.cwd(), 'src', 'public'))) app.use(logAll)\rUtilisations : DÃ©bogage : Winston est souvent utilisÃ© pour capturer des erreurs et des messages de dÃ©bogage pendant le dÃ©veloppement. Surveillance en Production : En production, Winston permet de centraliser les logs pour surveiller le bon fonctionnement de lâ€™application et diagnostiquer les problÃ¨mes. Audit et TraÃ§abilitÃ© : Winston peut Ãªtre configurÃ© pour capturer des logs spÃ©cifiques pour lâ€™audit, la sÃ©curitÃ© ou la traÃ§abilitÃ© des Ã©vÃ©nements critiques. Liens utiles : Formation : https://app.pluralsight.com/library/courses/nodejs-express-foundations\nArticle : Guide Winston\nDocumentation : Github Winston",
    "description": "Introduction Ã  Express Express est un framework web minimaliste pour Node.js, permettant de crÃ©er des applications web robustes et modulaires. Il facilite la gestion des routes, le rendu de vues dynamiques, et lâ€™intÃ©gration de middlewares pour diverses tÃ¢ches comme les sessions ou lâ€™authentification.\nExemple dâ€™Express const express = require(\"express\"); const app = express(); const port = 3000; app.get(\"/\", (req, res) =\u003e { res.send(\"Hello World!\"); }); app.listen(port, () =\u003e { console.log(`Application Ã  l'Ã©coute sur le port ${port}!`); });",
    "tags": [],
    "title": "ğŸ“˜ Express",
    "uri": "/420-514/nodejsframeworkexpress/express/index.html"
  },
  {
    "breadcrumb": "Collecte et interprÃ©tation de donnÃ©esÂ \u003eÂ Cadriciel (framework) cÃ´tÃ© serveur : Node.js / express",
    "content": "1. Installer Node.js Assurez-vous que Node.js est installÃ© sur votre machine. Vous pouvez le tÃ©lÃ©charger depuis le site officiel de Node.js.\nVÃ©rifier lâ€™installation : node -v npm -v\rExÃ©cuter un script : // hello.js console.log(\"Hello Node.js ğŸš€\");\rPuis :\nnode hello.js\r2. Initialiser un nouveau projet Node.js Ouvrez votre terminal et crÃ©ez un nouveau dossier pour votre projet. AccÃ©dez Ã  ce dossier, puis exÃ©cutez la commande suivante pour initialiser un nouveau projet Node.js :\nmkdir mon-projet-express cd mon-projet-express npm init -y\rLe drapeau -y accepte les valeurs par dÃ©faut pour toutes les options, crÃ©ant ainsi un fichier package.json de base.\n3. Installer Express.js Installez Express.js en tant que dÃ©pendance dans votre projet :\nnpm install express --save Express facilite la gestion des routes et des rÃ©ponses.\n4. Configurer le serveur Express CrÃ©ez un fichier index.js dans le dossier racine de votre projet, puis ajoutez-y le code suivant pour configurer un serveur de base avec Express.js :\nconst express = require('express'); const app = express(); const port = 3000; app.get('/', (req, res) =\u003e { res.send('Hello, World!'); }); app.listen(port, () =\u003e { console.log(`Serveur en Ã©coute sur \u003chttp://localhost\u003e:${port}`); });\r5. DÃ©marrer le serveur Vous pouvez maintenant dÃ©marrer votre serveur en exÃ©cutant la commande suivante dans votre terminal :\nnode index.js\rCela dÃ©marrera le serveur et affichera Serveur en Ã©coute sur http://localhost:3000. Vous pouvez accÃ©der Ã  cette URL via votre navigateur pour voir le message â€œHello, World!â€.\n6. Installer nodemon pour un dÃ©veloppement plus efficace Pour un dÃ©veloppement plus pratique, vous pouvez installer nodemon. Cet outil redÃ©marre automatiquement le serveur Ã  chaque fois que vous modifiez le code :\nnpm install -g nodemon\rEnsuite, au lieu de lancer votre serveur avec node index.js, utilisez :\nnodemon index.js\rSi vous rencontrez cette erreur sur Windows :\nVous pouvez la restriction de la politique de sÃ©curitÃ© avec la commande suivante :\nSet-ExecutionPolicy RemoteSigned -Scope CurrentUser\rOn peut aussi dÃ©marrer le serveur node en mode watch-path pour une mise Ã  jour immÃ©diate Ã  chaque fois un fichier dans le dossier racine change. Il faut donc dÃ©placer votre fichier dans un dossier src :\nnode --watch-path=./src .\\src\\index.js\r7. Structurer votre projet Il est recommandÃ© de structurer votre projet de maniÃ¨re Ã  ce quâ€™il soit facilement maintenable :\nindex.js : Point dâ€™entrÃ©e de lâ€™application. routes/ : Contient les fichiers de routage. controllers/ : Logique mÃ©tier. models/ : ModÃ¨les de donnÃ©es si vous utilisez une base de donnÃ©es. public/ : Contient les fichiers statiques comme les CSS, images, etc. views/ : Si vous utilisez un moteur de template comme EJS ou Pug. 8. Ajouter des middlewares Vous pouvez ajouter des middlewares pour gÃ©rer les requÃªtes, comme le parsing des corps de requÃªtes JSON :\napp.use(express.json()); app.use(express.urlencoded({ extended: true }));\r9. Ajouter des routes supplÃ©mentaires CommenÃ§ons par ajouter des routes supplÃ©mentaires dans votre application. Pour une meilleure organisation, nous allons crÃ©er un dossier routes/ oÃ¹ nous stockerons les diffÃ©rents fichiers de routes.\nconst express = require('express'); const app = express(); const port = 3000; // Route de base qui renvoie un message de bienvenue app.get('/', (req, res) =\u003e { res.send('Bienvenue sur mon serveur Express!'); }); // Route pour afficher un message personnalisÃ© app.get('/hello/:name', (req, res) =\u003e { const name = req.params.name; res.send(`Bonjour, ${name}!`); }); // Route qui renvoie les informations sur le serveur app.get('/info', (req, res) =\u003e { res.json({ version: '1.0.0', description: 'Ceci est un serveur simple utilisant Express.js', }); }); // DÃ©marrer le serveur app.listen(port, () =\u003e { console.log(`Serveur en Ã©coute sur \u003chttp://localhost\u003e:${port}`); });\r9.1 CrÃ©er un fichier de routes CrÃ©ez un fichier routes/users.js :\nconst express = require('express'); const router = express.Router(); // Route pour rÃ©cupÃ©rer tous les utilisateurs router.get('/', (req, res) =\u003e { res.send('Liste des utilisateurs'); }); // Route pour rÃ©cupÃ©rer un utilisateur par ID router.get('/:id', (req, res) =\u003e { res.send(`Utilisateur avec ID ${req.params.id}`); }); module.exports = router;\r9.2 Utiliser les routes dans lâ€™application principale Modifiez votre fichier index.js pour inclure ces nouvelles routes :\nconst express = require('express'); const app = express(); const port = 3000; const userRoutes = require('./routes/users'); app.use(express.json()); app.use(express.urlencoded({ extended: true })); // Route de base app.get('/', (req, res) =\u003e { res.send('Hello, World!'); }); // Utiliser les routes dÃ©finies dans le fichier users.js app.use('/users', userRoutes); app.listen(port, () =\u003e { console.log(`Serveur en Ã©coute sur \u003chttp://localhost\u003e:${port}`); });\r10. AccÃ¨s aux fichiers const fs = require('fs'); // Ã‰criture fs.writeFileSync('data.txt', 'Hello Node!'); // Lecture const data = fs.readFileSync('data.txt', 'utf8'); console.log(data);\r11. Asynchrone et promises const fs = require('fs').promises; async function readFile() { try { const data = await fs.readFile('data.txt', 'utf8'); console.log(data); } catch (err) { console.error(err); } } readFile();",
    "description": "1. Installer Node.js Assurez-vous que Node.js est installÃ© sur votre machine. Vous pouvez le tÃ©lÃ©charger depuis le site officiel de Node.js.\nVÃ©rifier lâ€™installation : node -v npm -v\rExÃ©cuter un script : // hello.js console.log(\"Hello Node.js ğŸš€\");\rPuis :\nnode hello.js\r2. Initialiser un nouveau projet Node.js Ouvrez votre terminal et crÃ©ez un nouveau dossier pour votre projet. AccÃ©dez Ã  ce dossier, puis exÃ©cutez la commande suivante pour initialiser un nouveau projet Node.js :",
    "tags": [],
    "title": "ğŸ§ª Laboratoire : Commencer avec Node.js et Express.js",
    "uri": "/420-514/nodejsframeworkexpress/lab/index.html"
  },
  {
    "breadcrumb": "Collecte et interprÃ©tation de donnÃ©esÂ \u003eÂ Cadriciel (framework) cÃ´tÃ© serveur : Node.js / express",
    "content": "Partie 1 : Ajouter des middlewares pour la gestion des erreurs et le logging Ajouter un middleware de logging\nCrÃ©ez un middleware qui enregistre chaque requÃªte reÃ§ue par le serveur. ImplÃ©mentez le code suivant au dÃ©but de votre fichier index.js : const express = require('express'); const app = express(); const port = 3000; // Middleware de logging app.use((req, res, next) =\u003e { console.log(`${req.method} ${req.url}`); next(); });\rAjouter un middleware de gestion des erreurs\nCrÃ©ez un middleware pour intercepter les erreurs et envoyer une rÃ©ponse appropriÃ©e. Placez ce middleware Ã  la fin de toutes vos routes dans index.js : // Middleware de gestion des erreurs app.use((err, req, res, next) =\u003e { console.error(err.stack); res.status(500).send('Une erreur est survenue!'); });\rPartie 2 : Servir des fichiers statiques CrÃ©er un Dossier public\nCrÃ©ez un dossier public Ã  la racine de votre projet avec la commande suivante : mkdir public\rAjouter un fichier HTML dans le dossier public\nCrÃ©ez un fichier index.html dans le dossier public avec le contenu suivant : \u003c!DOCTYPE html\u003e \u003chtml lang=\"fr\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003ePage d'accueil\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eBienvenue sur mon site!\u003c/h1\u003e \u003cp\u003eCeci est une page HTML servie par Express.\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e\rConfigurer Express pour servir les fichiers statiques\nAjoutez le code suivant dans votre fichier index.js pour permettre Ã  Express de servir les fichiers du dossier public : // Servir des fichiers statiques app.use(express.static('public'));\rPartie 3 : Utiliser la librairie de journalisation Winston Installer Winston\nInstallez la librairie Winston en exÃ©cutant la commande suivante dans votre terminal : npm install winston\rConfigurer Winston\nAjoutez le code suivant dans votre fichier index.js pour configurer Winston et lâ€™intÃ©grer avec Express pour gÃ©rer les logs : const winston = require('winston'); // Configuration du logger avec Winston const logger = winston.createLogger({ level: 'info', format: winston.format.combine( winston.format.timestamp(), winston.format.json() ), transports: [ new winston.transports.Console(), new winston.transports.File({ filename: 'logs/app.log' }) ] }); // Middleware de logging utilisant Winston app.use((req, res, next) =\u003e { logger.info(`${req.method} ${req.url}`); next(); });\rPartie 4 : Tester les amÃ©liorations Test du middleware de logging Lancez votre serveur avec node index.js. AccÃ©dez Ã  diffÃ©rentes routes (par exemple, / ou /info) et vÃ©rifiez que les requÃªtes sont enregistrÃ©es dans le terminal et dans le fichier logs/app.log. Test du Middleware de Gestion des Erreurs CrÃ©ez une route qui lÃ¨ve une exception pour simuler une erreur :\napp.get('/cause-error', (req, res) =\u003e { throw new Error('Erreur simulÃ©e!'); });\rAccÃ©dez Ã  cette route via GET \u003chttp://localhost:3000/cause-error\u003e et observez le message dâ€™erreur personnalisÃ©.\nTest de la Servitude des Fichiers Statiques AccÃ©dez Ã  http://localhost:3000/ dans votre navigateur pour voir la page HTML servie par Express. Partie 5 : Fichier index.js complet Voici un exemple complet aprÃ¨s lâ€™ajout des middlewares et Winston :\nconst express = require('express'); const winston = require('winston'); const app = express(); const port = 3000; // Configuration du logger avec Winston const logger = winston.createLogger({ level: 'info', format: winston.format.combine( winston.format.timestamp(), winston.format.json() ), transports: [ new winston.transports.Console(), new winston.transports.File({ filename: 'logs/app.log' }) ] }); // Middleware de logging utilisant Winston app.use((req, res, next) =\u003e { logger.info(`${req.method} ${req.url}`); next(); }); // Servir des fichiers statiques app.use(express.static('public')); // Route de base app.get('/', (req, res) =\u003e { res.send('Bienvenue sur mon serveur Express!'); }); // Route pour afficher un message personnalisÃ© app.get('/hello/:name', (req, res) =\u003e { const name = req.params.name; res.send(`Bonjour, ${name}!`); }); // Route qui renvoie les informations sur le serveur app.get('/info', (req, res) =\u003e { res.json({ version: '1.0.0', description: 'Ceci est un serveur simple utilisant Express.js', }); }); // Route pour simuler une erreur app.get('/cause-error', (req, res) =\u003e { throw new Error('Erreur simulÃ©e!'); }); // Middleware de gestion des erreurs app.use((err, req, res, next) =\u003e { logger.error(err.stack); res.status(500).send('Une erreur est survenue!'); }); // DÃ©marrer le serveur app.listen(port, () =\u003e { console.log(`Serveur en Ã©coute sur \u003chttp://localhost\u003e:${port}`); });\rRÃ©sultats attendus Logging: Toutes les requÃªtes HTTP seront enregistrÃ©es dans la console et dans le fichier logs/app.log. Gestion des erreurs: En cas dâ€™erreur, un message dâ€™erreur appropriÃ© sera affichÃ©, et les dÃ©tails seront enregistrÃ©s dans les logs. Servitude de fichiers statiques: La page HTML situÃ©e dans le dossier public sera servie par Express lorsque lâ€™on accÃ¨de Ã  lâ€™URL racine du serveur.",
    "description": "Partie 1 : Ajouter des middlewares pour la gestion des erreurs et le logging Ajouter un middleware de logging\nCrÃ©ez un middleware qui enregistre chaque requÃªte reÃ§ue par le serveur. ImplÃ©mentez le code suivant au dÃ©but de votre fichier index.js : const express = require('express'); const app = express(); const port = 3000; // Middleware de logging app.use((req, res, next) =\u003e { console.log(`${req.method} ${req.url}`); next(); });\rAjouter un middleware de gestion des erreurs\nCrÃ©ez un middleware pour intercepter les erreurs et envoyer une rÃ©ponse appropriÃ©e. Placez ce middleware Ã  la fin de toutes vos routes dans index.js : // Middleware de gestion des erreurs app.use((err, req, res, next) =\u003e { console.error(err.stack); res.status(500).send('Une erreur est survenue!'); });\rPartie 2 : Servir des fichiers statiques CrÃ©er un Dossier public",
    "tags": [],
    "title": "ğŸ§ª Laboratoire : Gestion des Erreurs et Logging",
    "uri": "/420-514/nodejsframeworkexpress/lab2/index.html"
  },
  {
    "breadcrumb": "Collecte et interprÃ©tation de donnÃ©esÂ \u003eÂ RequÃªtes HTTP et format de donnÃ©es",
    "content": "Le protocole HTTP HTTP (HyperText Transfer Protocol) est le protocole qui permet dâ€™Ã©changer des donnÃ©es sur le Web.\nIl fonctionne selon un modÃ¨le client-serveur : câ€™est toujours le client (navigateur) qui envoie une requÃªte, et le serveur qui rÃ©pond.\nHTTP est utilisÃ© pour rÃ©cupÃ©rer diffÃ©rentes ressources :\ndocuments HTML, feuilles de style (CSS), images, vidÃ©os, scripts, etc. Un document web complet est construit en combinant tous ces sous-documents envoyÃ©s par le serveur.\nParties dâ€™une RequÃªte HTTP URL (Uniform Resource Locator): Lâ€™adresse de la ressource demandÃ©e.\nExemple: https://api.example.com/users/123 Cette URL accÃ¨de Ã  la ressource utilisateur avec lâ€™ID 123. MÃ©thode HTTP: Le verbe HTTP utilisÃ© pour la requÃªte (GET, POST, etc.).\nEn-tÃªtes (Headers): Informations supplÃ©mentaires sur la requÃªte.\nCorps (Body): Contenu de la requÃªte (souvent utilisÃ© avec POST et PUT).\nExemple:\n{ \"username\": \"johndoe\", \"email\": \"john@example.com\" }\rLe corps contient les donnÃ©es envoyÃ©es au serveur pour crÃ©er ou mettre Ã  jour une ressource.\n1. URL Le chemin de la ressource Ã  extraire correspond Ã  lâ€™URL simplifiÃ©e de la ressource, dont on a retirÃ© les Ã©lÃ©ments dÃ©jÃ  implicites dans le contexte, comme le protocole (http://), le nom de domaine (ex. .mozilla.org) ou encore le port TCP par dÃ©faut (ex. 80).\n2. MÃ©thodes HTTP (GET, POST, PUT, DELETE) Une mÃ©thode HTTP est une instruction envoyÃ©e par le client au serveur pour prÃ©ciser lâ€™action Ã  effectuer sur une ressource. Le plus souvent, il sâ€™agit dâ€™un verbe comme GET (rÃ©cupÃ©rer une ressource) ou POST (envoyer des donnÃ©es, par exemple le contenu dâ€™un formulaire). Il existe aussi dâ€™autres mÃ©thodes comme OPTIONS ou HEAD, qui permettent dâ€™effectuer des opÃ©rations spÃ©cifiques selon le contexte. - Exemple: POST /users HTTP/1.1 - Cette mÃ©thode indique que la requÃªte envoie des donnÃ©es pour crÃ©er un nouvel utilisateur.\n3. En-tÃªtes (Headers) Ce sont des paires clÃ©-valeur qui fournissent des informations supplÃ©mentaires sur la requÃªte.\nObligatoires : Host (nom du serveur). Optionnels : User-Agent, Content-Type, Accept, Authorization, etc. ğŸ‘‰ Exemple :\nHost: www.exemple.com\rUser-Agent: Mozilla/5.0\rAccept: text/html\rLes en-tÃªtes optionnels servent Ã  transmettre des informations complÃ©mentaires destinÃ©es au serveur, afin de prÃ©ciser ou dâ€™adapter le traitement de la requÃªte.\nğŸ‘‰ Exemple:\n```\rContent-Type: application/json\rAuthorization: Bearer your-token-here\r```\rSachant que : Content-Type indique que le corps de la requÃªte est en format JSON. Authorization envoie un token dâ€™authentification. Exemples dâ€™entÃªtes : En-tÃªte Exemple RÃ´le Host Host: www.exemple.com Indique le nom de domaine du serveur demandÃ© (obligatoire en HTTP/1.1). User-Agent User-Agent: Mozilla/5.0 Fournit des infos sur le client (navigateur, OS, version). Accept Accept: text/html, application/json Indique les formats de rÃ©ponse que le client peut accepter. Content-Type Content-Type: application/json SpÃ©cifie le format des donnÃ©es envoyÃ©es au serveur. Content-Length Content-Length: 256 Taille du corps de la requÃªte (en octets). Authorization Authorization: Bearer \u003ctoken\u003e Transmet un jeton ou identifiant pour authentifier le client. Cookie Cookie: sessionId=xyz Envoie des donnÃ©es de session ou de suivi au serveur. Cache-Control Cache-Control: no-cache Indique comment gÃ©rer la mise en cache des ressources. Referer Referer: https://google.com Indique la page dâ€™oÃ¹ vient la requÃªte. Accept-Language Accept-Language: fr-FR SpÃ©cifie la langue prÃ©fÃ©rÃ©e du client. Filtres dâ€™Origines des RequÃªtes (CORS) CORS (Cross-Origin Resource Sharing) : Un mÃ©canisme qui permet au serveur de spÃ©cifier quelles origines (domaines) peuvent accÃ©der Ã  ses ressources.\nExemple: Si une application JavaScript sur https://frontend.example.com veut faire une requÃªte vers https://api.example.com, mais que CORS nâ€™est pas configurÃ©, le navigateur bloquera la requÃªte.\nSolution avec CORS: Le serveur https://api.example.com peut configurer CORS pour autoriser les requÃªtes provenant de https://frontend.example.com :\nconst cors = require('cors'); app.use(cors({ origin: '\u003chttps://frontend.example.com\u003e' }));\rOn peut aussi spÃ©cifier les mÃ©thodes qui sont autorisÃ©es sur cette route et headers quâ€™on peut ajouter Ã  notre requÃªte :\nconst express = require('express'); const cors = require('cors'); const app = express(); app.use(cors({ origin: ['http://example.com', 'https://api.example.com'], methods: ['GET', 'POST', 'PUT', 'DELETE'], allowedHeaders: ['Content-Type', 'Authorization'] }));\r4. Corps Sert Ã  transmettre des donnÃ©es au serveur (ex. formulaire HTML, JSON, fichier).\nPrÃ©sent uniquement dans certaines mÃ©thodes (ex. POST, PUT).\nExemple : POST /api/users HTTP/1.1 Host: api.exemple.com Content-Type: application/json Content-Length: 45 { \"nom\": \"Alice\", \"email\": \"alice@mail.com\" }\rFormats de DonnÃ©es : JSON et XML JSON (JavaScript Object Notation) : Un format de donnÃ©es lÃ©ger, facile Ã  lire pour les humains et Ã  analyser par les machines.\nExemple :\n{ \"name\": \"John Doe\", \"age\": 30, \"city\": \"New York\" }\rUtilisation: JSON est couramment utilisÃ© pour les API RESTful, oÃ¹ les donnÃ©es sont Ã©changÃ©es entre le client et le serveur sous forme de paires clÃ©-valeur.\nXML (eXtensible Markup Language) : Un format de donnÃ©es structurÃ© utilisant des balises, similaire au HTML.\nExemple :\n\u003cperson\u003e \u003cname\u003eJohn Doe\u003c/name\u003e \u003cage\u003e30\u003c/age\u003e \u003ccity\u003eNew York\u003c/city\u003e \u003c/person\u003e\rUtilisation: XML est utilisÃ© dans des systÃ¨mes plus anciens ou pour des Ã©changes de donnÃ©es dans des environnements nÃ©cessitant un balisage strict, comme les services SOAP.",
    "description": "Le protocole HTTP HTTP (HyperText Transfer Protocol) est le protocole qui permet dâ€™Ã©changer des donnÃ©es sur le Web.\nIl fonctionne selon un modÃ¨le client-serveur : câ€™est toujours le client (navigateur) qui envoie une requÃªte, et le serveur qui rÃ©pond.\nHTTP est utilisÃ© pour rÃ©cupÃ©rer diffÃ©rentes ressources :\ndocuments HTML, feuilles de style (CSS), images, vidÃ©os, scripts, etc. Un document web complet est construit en combinant tous ces sous-documents envoyÃ©s par le serveur.",
    "tags": [],
    "title": "ğŸ“˜ RequÃªtes HTTP",
    "uri": "/420-514/httprequestdataformat/httprequest/index.html"
  },
  {
    "breadcrumb": "Collecte et interprÃ©tation de donnÃ©esÂ \u003eÂ RequÃªtes HTTP et format de donnÃ©es",
    "content": "ğŸ”¹ DÃ©finition Une requÃªte asynchrone est une requÃªte qui ne bloque pas lâ€™exÃ©cution du programme pendant lâ€™attente de la rÃ©ponse. Le programme peut continuer Ã  effectuer dâ€™autres tÃ¢ches, et traite la rÃ©ponse uniquement lorsquâ€™elle est disponible (via un mÃ©canisme de notification, callback, promesse, ou Ã©vÃ©nement).\nğŸ”¹ Pourquoi asynchrone ? Performance : Ã©viter quâ€™une application soit bloquÃ©e par une opÃ©ration lente (accÃ¨s rÃ©seau, lecture disque). ScalabilitÃ© : permettre Ã  un serveur de gÃ©rer plusieurs connexions simultanÃ©es. ExpÃ©rience utilisateur : garder les interfaces rÃ©actives (ex. : chargement dâ€™un contenu sans recharger toute la page). ğŸ”¹ Cas dâ€™utilisation Web : AJAX (Asynchronous JavaScript and XML) pour charger des donnÃ©es sans recharger la page. Applications mobiles : appel Ã  une API distante tout en maintenant lâ€™interface fluide. SystÃ¨mes distribuÃ©s : communication entre microservices. Base de donnÃ©es : requÃªtes envoyÃ©es en tÃ¢che de fond. ğŸ”¹ Comparaison avec les requÃªtes synchrones Synchrone : le programme attend la fin de la requÃªte avant de continuer â†’ simple, mais bloquant. Asynchrone : le programme envoie la requÃªte, continue dâ€™exÃ©cuter dâ€™autres instructions, puis gÃ¨re la rÃ©ponse quand elle arrive. ğŸ”¹ Modes de gestion Callbacks : fonction appelÃ©e quand la rÃ©ponse arrive. Promesses : objet reprÃ©sentant une valeur future (rÃ©solue ou rejetÃ©e). async/await : syntaxe moderne pour Ã©crire du code asynchrone de maniÃ¨re lisible. Ã‰vÃ©nements/observables : modÃ¨le rÃ©actif, utile pour gÃ©rer des flux continus de donnÃ©es. ğŸ”¹ Exemple gÃ©nÃ©rique (pseudo-code) print(\"DÃ©but du programme\")\renvoyer requÃªte asynchrone Ã  lâ€™API:\rquand la rÃ©ponse est reÃ§ue:\rafficher(\"RÃ©ponse :\", donnÃ©es)\rprint(\"Fin du programme (la rÃ©ponse arrivera plus tard)\")\rğŸ‘‰ RÃ©sultat : le programme affiche â€œDÃ©butâ€ et â€œFinâ€ immÃ©diatement, puis seulement aprÃ¨s lâ€™arrivÃ©e de la rÃ©ponse, il affiche les donnÃ©es.\nğŸ”¹ Exemples : Ci-dessous un exemple simple de requÃªte asynchrone pour chacun des modes de gestion(callbacks, promesses, async/await, Ã©vÃ©nements/observables).\nğŸ”¹ 1. Callbacks Câ€™est le style historique : on passe une fonction de rappel qui sera exÃ©cutÃ©e quand la rÃ©ponse arrive.\nfunction getDataCallback(url, callback) { fetch(url) .then(res =\u003e res.json()) .then(data =\u003e callback(null, data)) // succÃ¨s .catch(err =\u003e callback(err, null)); // erreur } console.log(\"DÃ©but\"); getDataCallback(\"https://jsonplaceholder.typicode.com/posts/1\", (err, data) =\u003e { if (err) { console.error(\"Erreur :\", err); } else { console.log(\"RÃ©ponse (callback) :\", data); } }); console.log(\"Fin (le callback arrivera plus tard)\");\rğŸ”¹ 2. Promises Une promesse reprÃ©sente une valeur qui sera disponible plus tard. On utilise .then() et .catch().\nconsole.log(\"DÃ©but\"); fetch(\"https://jsonplaceholder.typicode.com/posts/1\") .then(res =\u003e res.json()) .then(data =\u003e console.log(\"RÃ©ponse (promise) :\", data)) .catch(err =\u003e console.error(\"Erreur :\", err)); console.log(\"Fin\");\rğŸ”¹ 3. async/await Syntaxe moderne qui rend le code asynchrone plus lisible, comme du code synchrone.\nasync function getData() { try { console.log(\"DÃ©but\"); const res = await fetch(\"https://jsonplaceholder.typicode.com/posts/1\"); const data = await res.json(); console.log(\"RÃ©ponse (async/await) :\", data); console.log(\"Fin\"); } catch (err) { console.error(\"Erreur :\", err); } } getData();\rğŸ”¹ 4. Ã‰vÃ©nements / Observables Dans ce mode, la donnÃ©e arrive sous forme de flux continu (par exemple WebSocket, ou un Observable RxJS). Chaque rÃ©ponse est Ã©mise comme un Ã©vÃ©nement, et on y rÃ©agit avec un listener.\nExemple avec EventEmitter en Node.js : const EventEmitter = require('events'); const emitter = new EventEmitter(); // Abonnement Ã  l'Ã©vÃ©nement \"data\" emitter.on('data', (msg) =\u003e { console.log(\"DonnÃ©e reÃ§ue (event) :\", msg); }); // Simulation dâ€™arrivÃ©e asynchrone console.log(\"DÃ©but\"); setTimeout(() =\u003e emitter.emit('data', { id: 1, text: \"Bonjour ğŸ‘‹\" }), 1000); console.log(\"Fin (les donnÃ©es arrivent en Ã©vÃ©nement)\");\rExemple RxJS (Observables) : import { fromFetch } from \"rxjs/fetch\"; import { switchMap } from \"rxjs\"; console.log(\"DÃ©but\"); fromFetch(\"https://jsonplaceholder.typicode.com/posts/1\") .pipe(switchMap(res =\u003e res.json())) .subscribe({ next: data =\u003e console.log(\"RÃ©ponse (observable) :\", data), error: err =\u003e console.error(\"Erreur :\", err), complete: () =\u003e console.log(\"Flux terminÃ©\"), }); console.log(\"Fin\");\rNotion dâ€™asynchronisme avec Node.js En Node.js, la majoritÃ© des opÃ©rations liÃ©es aux Ã©changes de donnÃ©es (fichiers, rÃ©seau, API, base de donnÃ©es) sont asynchrones.\nCela signifie que le programme ne bloque pas pendant lâ€™attente dâ€™une rÃ©ponse : il continue Ã  exÃ©cuter dâ€™autres instructions et reprend le traitement lorsque le rÃ©sultat est disponible.\nCe comportement repose sur la boucle dâ€™Ã©vÃ©nements (event loop).\nPour rÃ©sumÃ© : Les requÃªtes asynchrones permettent de sÃ©parer lâ€™envoi et la rÃ©ception dâ€™une requÃªte, optimisant ainsi la performance, la rÃ©activitÃ© et la capacitÃ© Ã  traiter plusieurs opÃ©rations en parallÃ¨le.\nRÃ©sumÃ© des modes de gestion des rquÃªtes asynchrones :\nCallback : fonction dÃ©clenchÃ©e quand la rÃ©ponse arrive. Promise : objet reprÃ©sentant un rÃ©sultat futur (succÃ¨s ou erreur). async/await : syntaxe simplifiÃ©e basÃ©e sur les promesses. Ã‰vÃ©nements/Observables : idÃ©al pour flux continus de donnÃ©es. Autres ressources : MDN : Introduction au JavaScript asynchrone",
    "description": "ğŸ”¹ DÃ©finition Une requÃªte asynchrone est une requÃªte qui ne bloque pas lâ€™exÃ©cution du programme pendant lâ€™attente de la rÃ©ponse. Le programme peut continuer Ã  effectuer dâ€™autres tÃ¢ches, et traite la rÃ©ponse uniquement lorsquâ€™elle est disponible (via un mÃ©canisme de notification, callback, promesse, ou Ã©vÃ©nement).\nğŸ”¹ Pourquoi asynchrone ? Performance : Ã©viter quâ€™une application soit bloquÃ©e par une opÃ©ration lente (accÃ¨s rÃ©seau, lecture disque). ScalabilitÃ© : permettre Ã  un serveur de gÃ©rer plusieurs connexions simultanÃ©es. ExpÃ©rience utilisateur : garder les interfaces rÃ©actives (ex. : chargement dâ€™un contenu sans recharger toute la page). ğŸ”¹ Cas dâ€™utilisation Web : AJAX (Asynchronous JavaScript and XML) pour charger des donnÃ©es sans recharger la page. Applications mobiles : appel Ã  une API distante tout en maintenant lâ€™interface fluide. SystÃ¨mes distribuÃ©s : communication entre microservices. Base de donnÃ©es : requÃªtes envoyÃ©es en tÃ¢che de fond. ğŸ”¹ Comparaison avec les requÃªtes synchrones Synchrone : le programme attend la fin de la requÃªte avant de continuer â†’ simple, mais bloquant. Asynchrone : le programme envoie la requÃªte, continue dâ€™exÃ©cuter dâ€™autres instructions, puis gÃ¨re la rÃ©ponse quand elle arrive. ğŸ”¹ Modes de gestion Callbacks : fonction appelÃ©e quand la rÃ©ponse arrive. Promesses : objet reprÃ©sentant une valeur future (rÃ©solue ou rejetÃ©e). async/await : syntaxe moderne pour Ã©crire du code asynchrone de maniÃ¨re lisible. Ã‰vÃ©nements/observables : modÃ¨le rÃ©actif, utile pour gÃ©rer des flux continus de donnÃ©es. ğŸ”¹ Exemple gÃ©nÃ©rique (pseudo-code) print(\"DÃ©but du programme\")\renvoyer requÃªte asynchrone Ã  lâ€™API:\rquand la rÃ©ponse est reÃ§ue:\rafficher(\"RÃ©ponse :\", donnÃ©es)\rprint(\"Fin du programme (la rÃ©ponse arrivera plus tard)\")\rğŸ‘‰ RÃ©sultat : le programme affiche â€œDÃ©butâ€ et â€œFinâ€ immÃ©diatement, puis seulement aprÃ¨s lâ€™arrivÃ©e de la rÃ©ponse, il affiche les donnÃ©es.",
    "tags": [],
    "title": "ğŸŒ RequÃªtes asynchrones",
    "uri": "/420-514/httprequestdataformat/asyncrequest/index.html"
  },
  {
    "breadcrumb": "Collecte et interprÃ©tation de donnÃ©esÂ \u003eÂ RequÃªtes HTTP et format de donnÃ©es",
    "content": "JSON et XML La manipulation de donnÃ©es JSON et XML est essentielle dans le dÃ©veloppement dâ€™applications web modernes, car ces formats sont couramment utilisÃ©s pour lâ€™Ã©change de donnÃ©es entre les serveurs et les clients. Voici un guide sur la faÃ§on de manipuler ces donnÃ©es en utilisant JavaScript.\n1. Manipulation de donnÃ©es JSON JSON (JavaScript Object Notation) est un format de donnÃ©es lÃ©ger, facile Ã  lire et Ã  Ã©crire pour les humains, et facile Ã  analyser et Ã  gÃ©nÃ©rer pour les machines.\nParser des donnÃ©es JSON Pour convertir une chaÃ®ne JSON en un objet JavaScript, vous pouvez utiliser JSON.parse.\nExemple :\nconst jsonString = '{\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}'; const obj = JSON.parse(jsonString); console.log(obj.name); // \"John\" console.log(obj.age); // 30 console.log(obj.city); // \"New York\"\rConvertir un Objet JavaScript en JSON Pour convertir un objet JavaScript en une chaÃ®ne JSON, utilisez JSON.stringify.\nExemple :\nconst obj = { name: \"John\", age: 30, city: \"New York\" }; const jsonString = JSON.stringify(obj); console.log(jsonString); // '{\"name\":\"John\",\"age\":30,\"city\":\"New York\"}'\rManipuler des donnÃ©es JSON Vous pouvez facilement accÃ©der, modifier, ajouter ou supprimer des propriÃ©tÃ©s dans un objet JSON.\nExemple :\nconst obj = { name: \"John\", age: 30, city: \"New York\" }; // AccÃ©der Ã  une propriÃ©tÃ© console.log(obj.name); // \"John\" // Modifier une propriÃ©tÃ© obj.age = 31; // Ajouter une nouvelle propriÃ©tÃ© obj.country = \"USA\"; // Supprimer une propriÃ©tÃ© delete obj.city; console.log(obj); // { name: \"John\", age: 31, country: \"USA\" }\r2. Manipulation de donnÃ©es XML XML (eXtensible Markup Language) est un format plus verbeux souvent utilisÃ© dans les systÃ¨mes plus anciens ou pour des besoins spÃ©cifiques. Manipuler XML en JavaScript nÃ©cessite un peu plus de code comparÃ© Ã  JSON.\nParser des donnÃ©es XML Pour analyser une chaÃ®ne XML en un objet Document, utilisez DOMParser.\nExemple :\nconst xmlString = ` \u003cperson\u003e \u003cname\u003eJohn\u003c/name\u003e \u003cage\u003e30\u003c/age\u003e \u003ccity\u003eNew York\u003c/city\u003e \u003c/person\u003e `; const parser = new DOMParser(); const xmlDoc = parser.parseFromString(xmlString, \"text/xml\"); console.log(xmlDoc.getElementsByTagName(\"name\")[0].childNodes[0].nodeValue); // \"John\" console.log(xmlDoc.getElementsByTagName(\"age\")[0].childNodes[0].nodeValue); // \"30\"\rConvertir un objet Document en chaÃ®ne XML Pour convertir un objet Document en une chaÃ®ne XML, utilisez XMLSerializer.\nExemple :\nconst serializer = new XMLSerializer(); const xmlString = serializer.serializeToString(xmlDoc); console.log(xmlString);\rManipuler des donnÃ©es XML Vous pouvez accÃ©der et modifier les nÅ“uds XML de maniÃ¨re similaire Ã  la manipulation du DOM HTML.\nExemple :\n// AccÃ©der Ã  un Ã©lÃ©ment const nameElement = xmlDoc.getElementsByTagName(\"name\")[0]; console.log(nameElement.textContent); // \"John\" // Modifier un Ã©lÃ©ment nameElement.textContent = \"Jane\"; // Ajouter un nouvel Ã©lÃ©ment const countryElement = xmlDoc.createElement(\"country\"); countryElement.textContent = \"USA\"; xmlDoc.getElementsByTagName(\"person\")[0].appendChild(countryElement); // Supprimer un Ã©lÃ©ment const cityElement = xmlDoc.getElementsByTagName(\"city\")[0]; cityElement.parentNode.removeChild(cityElement); console.log(new XMLSerializer().serializeToString(xmlDoc)); // \u003cperson\u003e\u003cname\u003eJane\u003c/name\u003e\u003cage\u003e30\u003c/age\u003e\u003ccountry\u003eUSA\u003c/country\u003e\u003c/person\u003e\rÃ€ retenir : JSON : Plus simple et natif pour JavaScript, facile Ã  manipuler avec JSON.parse et JSON.stringify. XML : NÃ©cessite plus de travail, avec des outils comme DOMParser et XMLSerializer pour lâ€™analyse et la sÃ©rialisation. Conversion entre JSON et XML : Non native, nÃ©cessite des fonctions personnalisÃ©es. Pour un affichage bien prÃ©sentable des fichier JSON sur le navigateur Chrome, vous pouvez installer lâ€™extension suivante :\nJSON Beautifier \u0026 Editor - Chrome Web Store",
    "description": "JSON et XML La manipulation de donnÃ©es JSON et XML est essentielle dans le dÃ©veloppement dâ€™applications web modernes, car ces formats sont couramment utilisÃ©s pour lâ€™Ã©change de donnÃ©es entre les serveurs et les clients. Voici un guide sur la faÃ§on de manipuler ces donnÃ©es en utilisant JavaScript.\n1. Manipulation de donnÃ©es JSON JSON (JavaScript Object Notation) est un format de donnÃ©es lÃ©ger, facile Ã  lire et Ã  Ã©crire pour les humains, et facile Ã  analyser et Ã  gÃ©nÃ©rer pour les machines.",
    "tags": [],
    "title": "ğŸ“˜ Manipulation de donnÃ©es",
    "uri": "/420-514/httprequestdataformat/dataformat/index.html"
  },
  {
    "breadcrumb": "Collecte et interprÃ©tation de donnÃ©esÂ \u003eÂ Ressources utiles",
    "content": "Introduction Ã  Git Git est un logiciel de contrÃ´le de version. Il permet de gÃ©rer des fichiers et leur Ã©volution dans le temps.\nIl permet de retracer lâ€™origine de chaque modification, de rÃ©tablir des versions prÃ©cÃ©dentes et permet lâ€™intÃ©gration de modifications effectuÃ©es en parallÃ¨le.\nConcept Le principe dâ€™un gestionnaire de version est quâ€™il gÃ¨re un document comme â€œune baseâ€ Ã  laquelle est ajoutÃ© une suite de modifications.\nIl y a un dÃ©pÃ´t commun (Remote) et les contributeurs travaillent sur des versions locales.\nLorsquâ€™un contributeur a rÃ©alisÃ© une modification qui est prÃªte Ã  lâ€™envoyer, il pousse (push) celle-ci vers le dÃ©pÃ´t. Le dÃ©pÃ´t garde la trace avec un identifiant unique.\nGit est en fait un gestionnaire de version dÃ©centralisÃ©. Il y a 2 dÃ©pÃ´ts : remote et local. De plus, il maintient une version brouillon (staged, sandbox) sur le poste local.\nGit clone Lorsque vous devez rÃ©cupÃ©rer le code de votre repository (dÃ©pÃ´t remote):\ngit clone https://github.com/420-411-MV/demo-i18n.git\nSi vous avez configurÃ© la clef SSH dans github par exemple:\ngit clone git@github.com:cegepmv/420-411.git\nGit Commit Le principe de la commande commit est de dÃ©poser les modifications sur une dÃ©pÃ´t local. Il faut Ã©galement Ãªtre vigilant au niveau de la branche utilisÃ© pour le commit. De plus, il est important de mettre souvent Ã  jour la branche avant de procÃ©der Ã  un commit.\nLorsquâ€™on fait la commande commit, on doit y ajouter un message. En entreprise, on joint souvent un identifiant pour rÃ©fÃ©rer Ã  la tÃ¢che en cours. AprÃ¨s cet identifiant, on peut y mettre une description. Par exemple:\nâ€œPRJ-3428: Ajout de tests unitaires sur la mÃ©thode du service getClientsâ€\nLorsquâ€™on relie lâ€™identifiant et les commits, on peut alors connaÃ®tre le travail effectuÃ© dans le code pour une tÃ¢che donnÃ©e dans le systÃ¨me de gestion des projets (Jira, Clickup, Zoho, Zenhub, Asana, Monday.com, etc.).\ngit commit -m \"Votre message\"\rGit Push La commande git push permet de pousser (la branche actuelle de) le local vers le remote : git applique alors successivement tous les commit au remote.\nIl est fortement recommandÃ© de faire un git fetch / pull avant de procÃ©der Ã  celui-ci. Ã€ moins dâ€™Ãªtre seul dans ce repository et/ou la branche visÃ©e.\nGit Fetch, checkout, pull La commande git fetch permet de mettre Ã  jour notre dÃ©pÃ´t local en rÃ©cupÃ©rant lâ€™ Ã©tat courant qui remote. La commande git checkout permet de les appliquer Ã  la copie de travail (et donc de les voir).\nLa commande git pull fait les deux Ã  la fois.\nPensez Ã  vous mettre Ã  jour avant chaque session de travail !\nCâ€™est la premiÃ¨re chose quâ€™un dÃ©veloppeur fait chaque matin en se mettant au travail, dans beaucoup de cas.\nGit status La commande git status vous permet de connaÃ®tre lâ€™Ã©tat courant de vos copies locales (les modifications ont-elles Ã©tÃ© commitÃ©es, les fichiers ajoutÃ©s, les commit pushÃ©).\nLes interface graphiques (dont intelliJ) vous lâ€™indique souvent par des couleurs et icones.\nGit logs La commande vous permet de voir tous les commits et tous les identifiants (Commit ID) pour chaque commit effectuÃ©. Ces commit peuvent Ãªtre fort utili pour faire dâ€™autres commandes tel que git revert, git cherry-pick pour ne nommer que celles-ci.\nGit merge Cette commande permet dâ€™appliquer les changements (fusionner) dâ€™une autre branche Ã  votre branche sÃ©lectionnÃ©e dans votre repository locale. Il y a souvent des conflits lors dâ€™une fusion. Surtout si vous avez travailler dans un mÃªme fichier quâ€™un ou une de vos collÃ¨gues.\nVous devez tenter de rÃ©soudre les conflits avec des outils en ligne de commande ou Ã  lâ€™aide dâ€™un interface graphique. Câ€™est une habilitÃ© Ã  acquÃ©rir avec le temps. Câ€™est parfois trÃ¨s complexe et si lâ€™opÃ©ration nâ€™est pas effectÃ©e avec soin, il peut y avoir injection de bug.\n// on va sur la branche master\rgit checkout master\r// on merge hotfix dans master\rgit merge hotfix\rGit Rebase Le rebase consiste Ã  changer la base de votre branche dâ€™un commit vers un autre, donnant lâ€™illusion que vous avez crÃ©Ã© votre branche Ã  partir dâ€™un commit diffÃ©rent.\ngit rebase \u003cbase\u003e\rGit stash Lorsque vous voulez sauvegarder lâ€™Ã©tat actuel de votre rÃ©pertoire de travail. Câ€™est possible de le faire avec git stash et de revenir Ã  un rÃ©pertoire de travail propre sans ces modifications. Vous pourrez ensuite rÃ©cupÃ©rer ce travail en utilisant le nom que vous lui aurez donnÃ©. Vous pouvez en avoir plusieurs sauvegardÃ©s dans une liste.\n// Sauvegarder les changements courrants.\rgit stash\r// RÃ©cupÃ©rer les changements prÃ©cÃ©dents.\rgit stash pop\r// Voir la liste des stash\rgit stash list\rMeilleures pratiques Ne pas laisser les branches inactives. Effacer votre branche de bugfix ou de fonctionnalitÃ© si vous avez terminÃ©.\nNe pas prendre les branches pour plusieurs fonctionnalitÃ©s. SÃ©parez vos tÃ¢ches en plus petites et faites des commits plus souvent.\nRÃ©cupÃ©rer la branche parent le plus souvent possible. Soit en faisant un merge ou en faisant des rebases.\nCommuniquez avec votre Ã©quipe vos intentions! Ne travaillez pas sur les mÃªmes modules si possible.\nDans chaque Pull Request. Vous devriez ajouter des tests unitaires si vous avez travaillÃ© sur une fonctionnalitÃ© ou un fix.\nAvant le jour de la mise en production. Vous devriez crÃ©er une branche Ã  partir du main ou master. Donnez-lui le nom de MEP_4OCT_24 par exemple. Effectuez le merge de la branche RELEASE visÃ©e vers la branche de la copie de la production MEP_4OCT_24. Assurez-vous de bien merger tous les Ã©lÃ©ments. Testez que votre branche fonctionne et quâ€™elle est bien compilÃ©e. Le jour J de la mise en production. Mergez cette branche vers la production. Les conflits auront dÃ©jÃ  Ã©tÃ© rÃ©solus! Bingo.\nGitflow Pour maintenir une certain cohÃ©sion en entreprise, un modÃ¨le de branche a Ã©tÃ© proposÃ©. Il implique de sÃ©parer les branches de dÃ©veloppement et les branches primaires qui sont dÃ©ployÃ©s dans multiples environnements.\nSource:\nhttps://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow\nRÃ©fÃ©rence Richard E. Silverman (2013), Git Pocket Guide, Oâ€™Reilly\nAlice Jacquot, Introduction Ã  Git https://www.lri.fr/~jacquot/ipo/introAGit.pdf",
    "description": "Introduction Ã  Git Git est un logiciel de contrÃ´le de version. Il permet de gÃ©rer des fichiers et leur Ã©volution dans le temps.\nIl permet de retracer lâ€™origine de chaque modification, de rÃ©tablir des versions prÃ©cÃ©dentes et permet lâ€™intÃ©gration de modifications effectuÃ©es en parallÃ¨le.\nConcept Le principe dâ€™un gestionnaire de version est quâ€™il gÃ¨re un document comme â€œune baseâ€ Ã  laquelle est ajoutÃ© une suite de modifications.\nIl y a un dÃ©pÃ´t commun (Remote) et les contributeurs travaillent sur des versions locales.",
    "tags": [],
    "title": "Gestionnaire de source",
    "uri": "/420-514/ressourcesutiles/gestioncodesource/index.html"
  },
  {
    "breadcrumb": "Collecte et interprÃ©tation de donnÃ©esÂ \u003eÂ PrÃ©alables",
    "content": "Cadriciel cÃ´tÃ© serveur Quâ€™est-ce quâ€™un cadriciel cÃ´tÃ© serveur ? Un cadriciel (ou framework) est un ensemble structurÃ© dâ€™outils, de bibliothÃ¨ques et de conventions qui facilite et accÃ©lÃ¨re le dÃ©veloppement dâ€™applications. Lorsquâ€™on parle de cadriciel cÃ´tÃ© serveur, on fait rÃ©fÃ©rence aux frameworks conÃ§us pour la partie backend dâ€™une application, câ€™est-Ã -dire :\nla logique mÃ©tier (traitement des donnÃ©es, rÃ¨gles dâ€™affaires) la gestion des requÃªtes/rÃ©ponses entre le client et le serveur la communication avec les bases de donnÃ©es la sÃ©curitÃ© et la gestion des utilisateurs En dâ€™autres termes, au lieu de tout programmer Â« Ã  la main Â», on sâ€™appuie sur une infrastructure dÃ©jÃ  prÃªte qui propose des solutions Ã©prouvÃ©es et standardisÃ©es.\nPourquoi utiliser un cadriciel cÃ´tÃ© serveur ? Gain de temps et productivitÃ© : on Ã©vite de rÃ©inventer la roue pour gÃ©rer les routes, la sÃ©curitÃ©, ou encore les sessions. Organisation du code : un framework impose une structure claire (souvent basÃ©e sur le modÃ¨le MVC ou MVVM). SÃ©curitÃ© intÃ©grÃ©e : gestion des failles courantes (injections SQL, XSS, CSRF, etc.). Ã‰volutivitÃ© : plus simple dâ€™ajouter de nouvelles fonctionnalitÃ©s. CommunautÃ© et support : documentation, forums, mises Ã  jour rÃ©guliÃ¨res. Exemples de cadriciels cÃ´tÃ© serveur Node.js / Express.js (JavaScript / TypeScript) Django et Flask (Python) Spring Boot (Java) ASP.NET Core (C#) Laravel et Symfony (PHP)",
    "description": "Cadriciel cÃ´tÃ© serveur Quâ€™est-ce quâ€™un cadriciel cÃ´tÃ© serveur ? Un cadriciel (ou framework) est un ensemble structurÃ© dâ€™outils, de bibliothÃ¨ques et de conventions qui facilite et accÃ©lÃ¨re le dÃ©veloppement dâ€™applications. Lorsquâ€™on parle de cadriciel cÃ´tÃ© serveur, on fait rÃ©fÃ©rence aux frameworks conÃ§us pour la partie backend dâ€™une application, câ€™est-Ã -dire :\nla logique mÃ©tier (traitement des donnÃ©es, rÃ¨gles dâ€™affaires) la gestion des requÃªtes/rÃ©ponses entre le client et le serveur la communication avec les bases de donnÃ©es la sÃ©curitÃ© et la gestion des utilisateurs En dâ€™autres termes, au lieu de tout programmer Â« Ã  la main Â», on sâ€™appuie sur une infrastructure dÃ©jÃ  prÃªte qui propose des solutions Ã©prouvÃ©es et standardisÃ©es.",
    "tags": [],
    "title": "ğŸ“˜ Cadriciels rappel",
    "uri": "/420-514/intro/frameworkbe/index.html"
  },
  {
    "breadcrumb": "",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Collecte et interprÃ©tation de donnÃ©es",
    "uri": "/420-514/index.html"
  },
  {
    "breadcrumb": "Collecte et interprÃ©tation de donnÃ©es",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/420-514/categories/index.html"
  },
  {
    "breadcrumb": "Collecte et interprÃ©tation de donnÃ©es",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/420-514/tags/index.html"
  }
]
