var relearn_searchindex = [
  {
    "breadcrumb": "Collecte et interprétation de données",
    "content": "Dans ce module nous ferons une courte révision des notions essentielles au cours.",
    "description": "Dans ce module nous ferons une courte révision des notions essentielles au cours.",
    "tags": [],
    "title": "Préalables",
    "uri": "/420-514/intro/index.html"
  },
  {
    "breadcrumb": "Collecte et interprétation de données",
    "content": "Dans ce module, on va développer une API ou une application serveur complète avec un cadriciel moderne.",
    "description": "Dans ce module, on va développer une API ou une application serveur complète avec un cadriciel moderne.",
    "tags": [],
    "title": "Cadriciel (framework) côté serveur : Node.js / express",
    "uri": "/420-514/nodejsframeworkexpress/index.html"
  },
  {
    "breadcrumb": "Collecte et interprétation de données \u003e Préalables",
    "content": "Rappel API REST 🌼 Une API REST se doit d’être sans état Stateless. La communication entre le client et le serveur ne doit pas dépendre d’un quelconque contexte provenant du serveur. 🌼 Ainsi, chaque requête doit contenir l’ensemble des informations nécessaires à son traitement. Cela permet au de traiter indifféremment les requêtes de plusieurs clients via de multiples instances de serveurs.\n🌼 Pour chaque réponse renvoyée par l’API, un code doit être envoyé, ce code correspond à l’état de la requête et dépend de la réussite ou non de celle-ci.\nLes codes de statuts les plus courants que l’on retrouve généralement sur le Web sont :\nCode Définition 200 OK Tout s’est bien passé 201 Created La création de la ressource s’est bien passée (il n’est pas rare que les attributs de la nouvelle ressource soient aussi renvoyés dans la réponse. Dans ce cas, l’URL de cette ressource nouvellement créée est ajoutée via un Header Location) 204 NO Content Même principe que pour la 201, mais cette fois-ci, le contenu de la ressource nouvellement créée ou modifiée n’est pas renvoyé en réponse 304 Not modified Le contenu n’a pas été modifié depuis la dernière fois qu’elle a été mise en cache 400 Bad request La demande n’a pas pu être traitée correctement 401 Unauthorized L’authentification a échoué 403 Forbidden L’accès à cette ressource n’est pas autorisé 404 Not found La ressource n’existe pas 500 Server error Le serveur a rencontré un problème Verbes HTTP (GET, POST, PUT, DELETE) GET\nExemple: Vous souhaitez afficher une liste d’articles sur un blog.\nRequête GET: GET /articles HTTP/1.1\nAction: Le serveur retourne une liste d’articles au format JSON.\nRéponse:\n[ { \"id\": 1, \"title\": \"Article 1\", \"content\": \"Contenu de l'article 1\" }, { \"id\": 2, \"title\": \"Article 2\", \"content\": \"Contenu de l'article 2\" } ]\rPOST\nExemple: Un utilisateur soumet un formulaire pour créer un nouvel article.\nRequête POST: POST /articles HTTP/1.1\nCorps de la requête:\n{ \"title\": \"Nouvel Article\", \"content\": \"Contenu du nouvel article\" }\rAction: Le serveur crée un nouvel article avec les données fournies. Réponse: 201 Created avec l’article créé en retour. PUT\nExemple: Un utilisateur souhaite mettre à jour un article existant.\nRequête PUT: PUT /articles/1 HTTP/1.1\nCorps de la requête:\n{ \"title\": \"Article mis à jour\", \"content\": \"Contenu mis à jour\" }\rAction: Le serveur met à jour l’article avec les nouvelles données\nRéponse: 200 OK avec l’article mis à jour en retour.\nDELETE\nExemple: Un utilisateur souhaite supprimer un article. Requête DELETE: DELETE /articles/1 HTTP/1.1 Action: Le serveur supprime l’article avec l’ID 1. Réponse: 204 No Content (pas de contenu retourné, car la ressource a été supprimée).",
    "description": "Rappel API REST 🌼 Une API REST se doit d’être sans état Stateless. La communication entre le client et le serveur ne doit pas dépendre d’un quelconque contexte provenant du serveur. 🌼 Ainsi, chaque requête doit contenir l’ensemble des informations nécessaires à son traitement. Cela permet au de traiter indifféremment les requêtes de plusieurs clients via de multiples instances de serveurs.\n🌼 Pour chaque réponse renvoyée par l’API, un code doit être envoyé, ce code correspond à l’état de la requête et dépend de la réussite ou non de celle-ci.",
    "tags": [],
    "title": "Révision",
    "uri": "/420-514/intro/revision/index.html"
  },
  {
    "breadcrumb": "Collecte et interprétation de données \u003e Cadriciel (framework) côté serveur : Node.js / express",
    "content": "Introduction à Node.js Historique Avant 2009 le langage (JavaScript) n’était utilisé qu’au côté client et ne peut être exécuté que dans le navigateur (browser) Le code JavaScript était donc cantonné au côté client. Il servait à :\nmanipuler le DOM (Document Object Model), valider des formulaires, créer des animations simples, ajouter de l’interactivité à la page. ⚠️ Aucune possibilité de gérer :\ndes fichiers sur le serveur, une base de données, un système de fichiers ou un réseau. Tout cela était réservé aux langages côté serveur (PHP, Java, Python, C#, etc.).\nEn 2009, Ryan Dahl introduit Node.js, une innovation qui a changé l’histoire de JavaScript. Node.js reprend le moteur V8 de Google Chrome (rapide et optimisé en C++).\nIl l’embarque en dehors du navigateur, créant un nouvel environnement d’exécution JavaScript côté serveur. Avec Node.js, JavaScript peut enfin :\nlire et écrire dans des fichiers, gérer des connexions réseau, dialoguer avec des bases de données, exécuter des applications serveur complètes. 👉 Environnement d’exécution = Node.js (hors navigateur)\n👉 Moteur = V8, mais intégré dans un cadre élargi avec des API système.\nAttention : moteur \u003c\u003e environnement\rMoteur JavaScript : logiciel qui traduit le code JavaScript en instructions machine. (Ex. : V8, SpiderMonkey). Environnement d’exécution : contexte dans lequel s’exécute le code, incluant le moteur + les API disponibles. Dans le navigateur : API DOM, événements, cookies… Dans Node.js : API fichiers, réseau, processus, modules système… Que’est-ce que c’est Node.js ? Node.js est un environnement d’exécution open-source pour créer des applications et outils côté serveur en JavaScript (tel que les APIs), utilisé hors navigateur (directement sur l’ordinateur ou le serveur). Node se distingue par d’excellentes performances, un code uniquement en JavaScript, et un vaste écosystème via NPM, ce qui simplifie le développement d’applications web performantes.\nSource : https://app.pluralsight.com/library/courses/nodejs-express-foundations/description\nAvantages de Node.js Performance : Optimisé pour les applications web évolutives, notamment en temps réel. Un langage unique : JavaScript est utilisé à la fois côté client et serveur. Écosystème NPM : Accès à de nombreuses bibliothèques réutilisables. Installer Node js Pour installer Node Js aller sur le lien suivant : https://nodejs.org/fr/download/package-manager\nExemples de code Hello Node.js : Un exemple simple de serveur web Node.js qui répond “Salut tout le monde”.\nfunction sayHello(name) { console.log(`Hello ${name}!`); } sayHello('students');\rLe système node module 🌍 Les objets globaux : Navigateur vs Node.js Dans le navigateur L’environnement d’exécution est le navigateur. L’objet global est : window. Tous les objets, fonctions ou variables globales sont attachés à window. Exemple :\nconsole.log(window.document); // Accède au DOM window.alert(\"Bonjour depuis le navigateur !\");\rDans Node.js L’environnement d’exécution est Node.js (hors navigateur). L’objet global est : global. Tous les objets et fonctions globales comme : console.log() setTimeout() clearTimeout() setInterval() clearInterval() etc. sont attachés à global.\nExemple :\nglobal.console.log(\"Salut depuis Node.js 👋\"); setTimeout(() =\u003e { global.console.log(\"Ceci s’exécute après 1 seconde\"); }, 1000);\r⚠️ Dans Node.js, il n’y a pas de window ni de document → pas de DOM.\nNode.js fournit aussi un alias globalThis, qui est un standard JavaScript moderne : js\rglobalThis.console.log(\"Salut avec globalThis\");\r👉 Ainsi, on a :\nNavigateur : window === globalThis ✅ Node.js : global === globalThis ✅ en résumé\nContexte Objet global Exemple Navigateur window window.alert(\"Bonjour\") Node.js global global.console.log(\"Salut\") Standard (les deux) globalThis globalThis.setTimeout(...) 📦 Les modules en Node.js En node chaque fichier est un module et les fonctions ainsi que les variables définies dans ce fichier ne sont disponible qu’à l’interieur de ce module. Cela permet :\nd’organiser le code en plusieurs fichiers, d’éviter la duplication, de partager des fonctionnalités entre projets. Types de modules dans Node.js Modules internes (built-in)\nDéjà fournis avec Node.js.\nExemples :\nfs (fichiers), http (serveur web), path (chemins de fichiers), os (système d’exploitation). const fs = require('fs'); fs.writeFileSync('test.txt', 'Bonjour Node.js !');\rModules locaux (créés par nous)\nNos propres fichiers .js. Exemple : // fichier math.js function addition(a, b) { return a + b; } module.exports = addition;\r// fichier app.js const addition = require('./math'); console.log(addition(2, 3)); // 5 Modules tiers (installés avec npm)\nModules créés par la communauté. Exemple : express, lodash, mongoose. npm install express\rconst express = require('express'); const app = express(); app.get('/', (req, res) =\u003e res.send('Hello Express 🚀')); app.listen(3000);\r📦Systèmes de modules a) CommonJS (historiquement utilisé par Node.js) Utilise require() pour importer. Utilise module.exports pour exporter. // math.js module.exports = { addition: (a, b) =\u003e a + b, multiplication: (a, b) =\u003e a * b };\r// app.js const math = require('./math'); console.log(math.addition(2, 3));\rb) ES Modules (standard moderne JavaScript) Utilise import / export. Nécessite d’ajouter \"type\": \"module\" dans package.json. // math.mjs export function addition(a, b) { return a + b; }\r// app.mjs import { addition } from './math.mjs'; console.log(addition(4, 5));\rVoici un résumé comparatif\nType de module Exemple import Exemple export CommonJS (par défaut Node.js) const x = require('./fichier') module.exports = ... ES Module (standard moderne) import x from './fichier.js' export default ... ou export function ... Utilisation des Modules Les modules permettent d’organiser et réutiliser le code. Vous pouvez créer et importer des modules en utilisant require().\nExemple de module :\nexports.area = function (width) { return width * width; }; exports.perimeter = function (width) { return 4 * width; };\rOu\n// dans mathOperations.js function add(a, b) { return a + b; } function subtract(a, b) { return a - b; } function multiply(a, b) { return a * b; } function divide(a, b) { if (b === 0) { throw new Error('Division par zéro'); } return a / b; } // Export des fonctions pour les rendre disponibles dans d'autres fichiers module.exports = { add, subtract, multiply, divide };\rExemple d’un simple serveur\nconst http = require(\"http\"); const hostname = \"127.0.0.1\"; const port = 8000; const server = http.createServer((req, res) =\u003e { res.writeHead(200, { \"Content-Type\": \"text/plain\" }); res.end(\"Salut tout le monde\"); }); server.listen(port, hostname, () =\u003e { console.log(`Le serveur tourne à l'adresse http:\\\\${hostname}:${port}/`); });\rGestion des paquets avec npm Initialiser un projet : npm init -y Installer un module : npm install express Sauvegarder en dépendances dans package.json. Scripts personnalisés :\n\"scripts\": { \"start\": \"node app.js\", \"dev\": \"nodemon app.js\" }\rLire et écrire dans des fichiers Node.js fournit le module fs (File System) :\n// files.js const fs = require('fs'); // Écriture fs.writeFileSync('message.txt', 'Bonjour Node.js !'); // Lecture const data = fs.readFileSync('message.txt', 'utf8'); console.log(\"Contenu du fichier :\", data);\rAsynchronisme en Node.js Node.js excelle dans les opérations asynchrones (lecture de fichiers, accès réseau).\n// async.js const fs = require('fs'); fs.readFile('message.txt', 'utf8', (err, data) =\u003e { if (err) throw err; console.log(\"Lecture asynchrone :\", data); }); console.log(\"Cette ligne s’affiche avant la lecture du fichier !\");\r👉 Résultat : la lecture se fait en arrière-plan, pendant que le reste du code continue à s’exécuter.\nGestion des événements (EventEmitter) Node.js est basé sur un modèle événementiel.\nconst EventEmitter = require('events'); const emitter = new EventEmitter(); emitter.on('salut', (nom) =\u003e { console.log(`Bonjour ${nom} !`); }); emitter.emit('salut', 'Alice');\r👉 Utile pour créer des systèmes réactifs (logs, notifications, etc.).\nLiens utiles : Site de Node.js :\nNode.js — Exécuter du JavaScript partout Documentation officielle de Node.js\nFormation : https://app.pluralsight.com/library/courses/nodejs-express-foundations",
    "description": "Introduction à Node.js Historique Avant 2009 le langage (JavaScript) n’était utilisé qu’au côté client et ne peut être exécuté que dans le navigateur (browser) Le code JavaScript était donc cantonné au côté client. Il servait à :\nmanipuler le DOM (Document Object Model), valider des formulaires, créer des animations simples, ajouter de l’interactivité à la page. ⚠️ Aucune possibilité de gérer :\ndes fichiers sur le serveur, une base de données, un système de fichiers ou un réseau. Tout cela était réservé aux langages côté serveur (PHP, Java, Python, C#, etc.).",
    "tags": [],
    "title": "NodeJs",
    "uri": "/420-514/nodejsframeworkexpress/nodejs/index.html"
  },
  {
    "breadcrumb": "Collecte et interprétation de données \u003e HTTPRequestDataFormat",
    "content": "Parties d’une Requête HTTP URL (Uniform Resource Locator): L’adresse de la ressource demandée. Exemple: https://api.example.com/users/123 Cette URL accède à la ressource utilisateur avec l’ID 123. Méthode HTTP: Le verbe HTTP utilisé pour la requête (GET, POST, etc.). Exemple: POST /users HTTP/1.1 Cette méthode indique que la requête envoie des données pour créer un nouvel utilisateur. En-têtes (Headers): Informations supplémentaires sur la requête. Exemple:\nContent-Type: application/json\rAuthorization: Bearer your-token-here\rSachant que : Content-Type indique que le corps de la requête est en format JSON. Authorization envoie un token d’authentification.\nCorps (Body): Contenu de la requête (souvent utilisé avec POST et PUT). Exemple:\n{ \"username\": \"johndoe\", \"email\": \"john@example.com\" }\rLe corps contient les données envoyées au serveur pour créer ou mettre à jour une ressource.",
    "description": "Parties d’une Requête HTTP URL (Uniform Resource Locator): L’adresse de la ressource demandée. Exemple: https://api.example.com/users/123 Cette URL accède à la ressource utilisateur avec l’ID 123. Méthode HTTP: Le verbe HTTP utilisé pour la requête (GET, POST, etc.). Exemple: POST /users HTTP/1.1 Cette méthode indique que la requête envoie des données pour créer un nouvel utilisateur. En-têtes (Headers): Informations supplémentaires sur la requête. Exemple:\nContent-Type: application/json\rAuthorization: Bearer your-token-here\rSachant que : Content-Type indique que le corps de la requête est en format JSON. Authorization envoie un token d’authentification.",
    "tags": [],
    "title": "Requêtes HTTP",
    "uri": "/420-514/httprequestdataformat/httprequest/index.html"
  },
  {
    "breadcrumb": "Collecte et interprétation de données \u003e HTTPRequestDataFormat",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Formats de données",
    "uri": "/420-514/httprequestdataformat/dataformat/index.html"
  },
  {
    "breadcrumb": "Collecte et interprétation de données \u003e Ressources utiles",
    "content": "Introduction à Git Git est un logiciel de contrôle de version. Il permet de gérer des fichiers et leur évolution dans le temps.\nIl permet de retracer l’origine de chaque modification, de rétablir des versions précédentes et permet l’intégration de modifications effectuées en parallèle.\nConcept Le principe d’un gestionnaire de version est qu’il gère un document comme “une base” à laquelle est ajouté une suite de modifications.\nIl y a un dépôt commun (Remote) et les contributeurs travaillent sur des versions locales.\nLorsqu’un contributeur a réalisé une modification qui est prête à l’envoyer, il pousse (push) celle-ci vers le dépôt. Le dépôt garde la trace avec un identifiant unique.\nGit est en fait un gestionnaire de version décentralisé. Il y a 2 dépôts : remote et local. De plus, il maintient une version brouillon (staged, sandbox) sur le poste local.\nGit clone Lorsque vous devez récupérer le code de votre repository (dépôt remote):\ngit clone https://github.com/420-411-MV/demo-i18n.git\nSi vous avez configuré la clef SSH dans github par exemple:\ngit clone git@github.com:cegepmv/420-411.git\nGit Commit Le principe de la commande commit est de déposer les modifications sur une dépôt local. Il faut également être vigilant au niveau de la branche utilisé pour le commit. De plus, il est important de mettre souvent à jour la branche avant de procéder à un commit.\nLorsqu’on fait la commande commit, on doit y ajouter un message. En entreprise, on joint souvent un identifiant pour référer à la tâche en cours. Après cet identifiant, on peut y mettre une description. Par exemple:\n“PRJ-3428: Ajout de tests unitaires sur la méthode du service getClients”\nLorsqu’on relie l’identifiant et les commits, on peut alors connaître le travail effectué dans le code pour une tâche donnée dans le système de gestion des projets (Jira, Clickup, Zoho, Zenhub, Asana, Monday.com, etc.).\ngit commit -m \"Votre message\"\rGit Push La commande git push permet de pousser (la branche actuelle de) le local vers le remote : git applique alors successivement tous les commit au remote.\nIl est fortement recommandé de faire un git fetch / pull avant de procéder à celui-ci. À moins d’être seul dans ce repository et/ou la branche visée.\nGit Fetch, checkout, pull La commande git fetch permet de mettre à jour notre dépôt local en récupérant l’ état courant qui remote. La commande git checkout permet de les appliquer à la copie de travail (et donc de les voir).\nLa commande git pull fait les deux à la fois.\nPensez à vous mettre à jour avant chaque session de travail !\nC’est la première chose qu’un développeur fait chaque matin en se mettant au travail, dans beaucoup de cas.\nGit status La commande git status vous permet de connaître l’état courant de vos copies locales (les modifications ont-elles été commitées, les fichiers ajoutés, les commit pushé).\nLes interface graphiques (dont intelliJ) vous l’indique souvent par des couleurs et icones.\nGit logs La commande vous permet de voir tous les commits et tous les identifiants (Commit ID) pour chaque commit effectué. Ces commit peuvent être fort utili pour faire d’autres commandes tel que git revert, git cherry-pick pour ne nommer que celles-ci.\nGit merge Cette commande permet d’appliquer les changements (fusionner) d’une autre branche à votre branche sélectionnée dans votre repository locale. Il y a souvent des conflits lors d’une fusion. Surtout si vous avez travailler dans un même fichier qu’un ou une de vos collègues.\nVous devez tenter de résoudre les conflits avec des outils en ligne de commande ou à l’aide d’un interface graphique. C’est une habilité à acquérir avec le temps. C’est parfois très complexe et si l’opération n’est pas effectée avec soin, il peut y avoir injection de bug.\n// on va sur la branche master\rgit checkout master\r// on merge hotfix dans master\rgit merge hotfix\rGit Rebase Le rebase consiste à changer la base de votre branche d’un commit vers un autre, donnant l’illusion que vous avez créé votre branche à partir d’un commit différent.\ngit rebase \u003cbase\u003e\rGit stash Lorsque vous voulez sauvegarder l’état actuel de votre répertoire de travail. C’est possible de le faire avec git stash et de revenir à un répertoire de travail propre sans ces modifications. Vous pourrez ensuite récupérer ce travail en utilisant le nom que vous lui aurez donné. Vous pouvez en avoir plusieurs sauvegardés dans une liste.\n// Sauvegarder les changements courrants.\rgit stash\r// Récupérer les changements précédents.\rgit stash pop\r// Voir la liste des stash\rgit stash list\rMeilleures pratiques Ne pas laisser les branches inactives. Effacer votre branche de bugfix ou de fonctionnalité si vous avez terminé.\nNe pas prendre les branches pour plusieurs fonctionnalités. Séparez vos tâches en plus petites et faites des commits plus souvent.\nRécupérer la branche parent le plus souvent possible. Soit en faisant un merge ou en faisant des rebases.\nCommuniquez avec votre équipe vos intentions! Ne travaillez pas sur les mêmes modules si possible.\nDans chaque Pull Request. Vous devriez ajouter des tests unitaires si vous avez travaillé sur une fonctionnalité ou un fix.\nAvant le jour de la mise en production. Vous devriez créer une branche à partir du main ou master. Donnez-lui le nom de MEP_4OCT_24 par exemple. Effectuez le merge de la branche RELEASE visée vers la branche de la copie de la production MEP_4OCT_24. Assurez-vous de bien merger tous les éléments. Testez que votre branche fonctionne et qu’elle est bien compilée. Le jour J de la mise en production. Mergez cette branche vers la production. Les conflits auront déjà été résolus! Bingo.\nGitflow Pour maintenir une certain cohésion en entreprise, un modèle de branche a été proposé. Il implique de séparer les branches de développement et les branches primaires qui sont déployés dans multiples environnements.\nSource:\nhttps://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow\nRéférence Richard E. Silverman (2013), Git Pocket Guide, O’Reilly\nAlice Jacquot, Introduction à Git https://www.lri.fr/~jacquot/ipo/introAGit.pdf",
    "description": "Introduction à Git Git est un logiciel de contrôle de version. Il permet de gérer des fichiers et leur évolution dans le temps.\nIl permet de retracer l’origine de chaque modification, de rétablir des versions précédentes et permet l’intégration de modifications effectuées en parallèle.\nConcept Le principe d’un gestionnaire de version est qu’il gère un document comme “une base” à laquelle est ajouté une suite de modifications.\nIl y a un dépôt commun (Remote) et les contributeurs travaillent sur des versions locales.",
    "tags": [],
    "title": "Gestionnaire de source",
    "uri": "/420-514/ressourcesutiles/gestioncodesource/index.html"
  },
  {
    "breadcrumb": "",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Collecte et interprétation de données",
    "uri": "/420-514/index.html"
  },
  {
    "breadcrumb": "Collecte et interprétation de données \u003e Préalables",
    "content": "Cadriciel côté serveur Qu’est-ce qu’un cadriciel côté serveur ? Un cadriciel (ou framework) est un ensemble structuré d’outils, de bibliothèques et de conventions qui facilite et accélère le développement d’applications. Lorsqu’on parle de cadriciel côté serveur, on fait référence aux frameworks conçus pour la partie backend d’une application, c’est-à-dire :\nla logique métier (traitement des données, règles d’affaires) la gestion des requêtes/réponses entre le client et le serveur la communication avec les bases de données la sécurité et la gestion des utilisateurs En d’autres termes, au lieu de tout programmer « à la main », on s’appuie sur une infrastructure déjà prête qui propose des solutions éprouvées et standardisées.\nPourquoi utiliser un cadriciel côté serveur ? Gain de temps et productivité : on évite de réinventer la roue pour gérer les routes, la sécurité, ou encore les sessions. Organisation du code : un framework impose une structure claire (souvent basée sur le modèle MVC ou MVVM). Sécurité intégrée : gestion des failles courantes (injections SQL, XSS, CSRF, etc.). Évolutivité : plus simple d’ajouter de nouvelles fonctionnalités. Communauté et support : documentation, forums, mises à jour régulières. Exemples de cadriciels côté serveur Node.js / Express.js (JavaScript / TypeScript) Django et Flask (Python) Spring Boot (Java) ASP.NET Core (C#) Laravel et Symfony (PHP)",
    "description": "Cadriciel côté serveur Qu’est-ce qu’un cadriciel côté serveur ? Un cadriciel (ou framework) est un ensemble structuré d’outils, de bibliothèques et de conventions qui facilite et accélère le développement d’applications. Lorsqu’on parle de cadriciel côté serveur, on fait référence aux frameworks conçus pour la partie backend d’une application, c’est-à-dire :\nla logique métier (traitement des données, règles d’affaires) la gestion des requêtes/réponses entre le client et le serveur la communication avec les bases de données la sécurité et la gestion des utilisateurs En d’autres termes, au lieu de tout programmer « à la main », on s’appuie sur une infrastructure déjà prête qui propose des solutions éprouvées et standardisées.",
    "tags": [],
    "title": "Cadriciels rappel",
    "uri": "/420-514/intro/frameworkbe/index.html"
  },
  {
    "breadcrumb": "Collecte et interprétation de données",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/420-514/categories/index.html"
  },
  {
    "breadcrumb": "Collecte et interprétation de données \u003e Cadriciel (framework) côté serveur : Node.js / express",
    "content": "1. Installer Node.js Assurez-vous que Node.js est installé sur votre machine. Vous pouvez le télécharger depuis le site officiel de Node.js.\nVérifier l’installation : node -v npm -v\rExécuter un script : // hello.js console.log(\"Hello Node.js 🚀\");\rPuis :\nnode hello.js\r2. Initialiser un Nouveau Projet Node.js Ouvrez votre terminal et créez un nouveau dossier pour votre projet. Accédez à ce dossier, puis exécutez la commande suivante pour initialiser un nouveau projet Node.js :\nmkdir mon-projet-express cd mon-projet-express npm init -y\rLe drapeau -y accepte les valeurs par défaut pour toutes les options, créant ainsi un fichier package.json de base.\n3. Installer Express.js Installez Express.js en tant que dépendance dans votre projet :\nnpm install express --save Express facilite la gestion des routes et des réponses.\n4. Configurer le Serveur Express Créez un fichier index.js dans le dossier racine de votre projet, puis ajoutez-y le code suivant pour configurer un serveur de base avec Express.js :\nconst express = require('express'); const app = express(); const port = 3000; app.get('/', (req, res) =\u003e { res.send('Hello, World!'); }); app.listen(port, () =\u003e { console.log(`Serveur en écoute sur \u003chttp://localhost\u003e:${port}`); });\r5. Démarrer le Serveur Vous pouvez maintenant démarrer votre serveur en exécutant la commande suivante dans votre terminal :\nnode index.js\rCela démarrera le serveur et affichera Serveur en écoute sur http://localhost:3000. Vous pouvez accéder à cette URL via votre navigateur pour voir le message “Hello, World!”.\n6. Installer Nodemon pour un Développement Plus Efficace Pour un développement plus pratique, vous pouvez installer nodemon. Cet outil redémarre automatiquement le serveur à chaque fois que vous modifiez le code :\nnpm install -g nodemon\rEnsuite, au lieu de lancer votre serveur avec node index.js, utilisez :\nnodemon index.js\rSi vous rencontrez cette erreur sur Windows :\nVous pouvez la restriction de la politique de sécurité avec la commande suivante :\nSet-ExecutionPolicy RemoteSigned -Scope CurrentUser\rOn peut aussi démarrer le serveur node en mode watch-path pour une mise à jour immédiate à chaque fois un fichier dans le dossier racine change. Il faut donc déplacer votre fichier dans un dossier src :\nnode --watch-path=./src .\\src\\index.js\r7. Structurer Votre Projet Il est recommandé de structurer votre projet de manière à ce qu’il soit facilement maintenable :\nindex.js : Point d’entrée de l’application. routes/ : Contient les fichiers de routage. controllers/ : Logique métier. models/ : Modèles de données si vous utilisez une base de données. public/ : Contient les fichiers statiques comme les CSS, images, etc. views/ : Si vous utilisez un moteur de template comme EJS ou Pug. 8. Ajouter des Middlewares Vous pouvez ajouter des middlewares pour gérer les requêtes, comme le parsing des corps de requêtes JSON :\napp.use(express.json()); app.use(express.urlencoded({ extended: true }));\r9. Ajouter des Routes Supplémentaires Commençons par ajouter des routes supplémentaires dans votre application. Pour une meilleure organisation, nous allons créer un dossier routes/ où nous stockerons les différents fichiers de routes.\nconst express = require('express'); const app = express(); const port = 3000; // Route de base qui renvoie un message de bienvenue app.get('/', (req, res) =\u003e { res.send('Bienvenue sur mon serveur Express!'); }); // Route pour afficher un message personnalisé app.get('/hello/:name', (req, res) =\u003e { const name = req.params.name; res.send(`Bonjour, ${name}!`); }); // Route qui renvoie les informations sur le serveur app.get('/info', (req, res) =\u003e { res.json({ version: '1.0.0', description: 'Ceci est un serveur simple utilisant Express.js', }); }); // Démarrer le serveur app.listen(port, () =\u003e { console.log(`Serveur en écoute sur \u003chttp://localhost\u003e:${port}`); });\r9.1 Créer un Fichier de Routes Créez un fichier routes/users.js :\nconst express = require('express'); const router = express.Router(); // Route pour récupérer tous les utilisateurs router.get('/', (req, res) =\u003e { res.send('Liste des utilisateurs'); }); // Route pour récupérer un utilisateur par ID router.get('/:id', (req, res) =\u003e { res.send(`Utilisateur avec ID ${req.params.id}`); }); module.exports = router;\r9.2 Utiliser les Routes dans l’Application Principale Modifiez votre fichier index.js pour inclure ces nouvelles routes :\nconst express = require('express'); const app = express(); const port = 3000; const userRoutes = require('./routes/users'); app.use(express.json()); app.use(express.urlencoded({ extended: true })); // Route de base app.get('/', (req, res) =\u003e { res.send('Hello, World!'); }); // Utiliser les routes définies dans le fichier users.js app.use('/users', userRoutes); app.listen(port, () =\u003e { console.log(`Serveur en écoute sur \u003chttp://localhost\u003e:${port}`); });\r10. Accès aux fichiers const fs = require('fs'); // Écriture fs.writeFileSync('data.txt', 'Hello Node!'); // Lecture const data = fs.readFileSync('data.txt', 'utf8'); console.log(data);\r11. Asynchrone et Promises const fs = require('fs').promises; async function readFile() { try { const data = await fs.readFile('data.txt', 'utf8'); console.log(data); } catch (err) { console.error(err); } } readFile();",
    "description": "1. Installer Node.js Assurez-vous que Node.js est installé sur votre machine. Vous pouvez le télécharger depuis le site officiel de Node.js.\nVérifier l’installation : node -v npm -v\rExécuter un script : // hello.js console.log(\"Hello Node.js 🚀\");\rPuis :\nnode hello.js\r2. Initialiser un Nouveau Projet Node.js Ouvrez votre terminal et créez un nouveau dossier pour votre projet. Accédez à ce dossier, puis exécutez la commande suivante pour initialiser un nouveau projet Node.js :",
    "tags": [],
    "title": "Laboratoire : Commencer avec Node.js et Express.js",
    "uri": "/420-514/nodejsframeworkexpress/lab/index.html"
  },
  {
    "breadcrumb": "Collecte et interprétation de données",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/420-514/tags/index.html"
  }
]
